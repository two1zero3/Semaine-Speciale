/* autogenerated by Processing revision 1293 on 2023-11-15 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import processing.javafx.*;
import processing.video.*;
import java.util.Calendar;
import net.java.games.input.*;
import org.gamecontrolplus.*;
import org.gamecontrolplus.gui.*;
import processing.sound.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class layoutTool extends PApplet {


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– LIBRARIES ––––––––––––––––










// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– EDITABLE VARIABLES –––––––

// Setup which controller setup you want to use to run the program.
boolean gamepad = true;
boolean gamepadFallback = false;
boolean keyboardFallback = false;

// Turn sound on or off
Boolean interfaceSound = true;
Boolean backgroundSound = true;

// Check the available cameras list in the console after program run to switch index
int cameraIndex = 0;


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SETUP ––––––––––––––––––––

public void setup() {
  /* size commented out by preprocessor */;

  // Setup all inputs
  setupInterface();
  setupSound();
  setupController();
  folder = new File(dataPath("input/"));
  loadFiles();

  // Set all items anchor points to its center.
  rectMode(CENTER);
  ellipseMode(CENTER);
  imageMode(CENTER);
  shapeMode(CENTER);

  // Add first item to work with
  addItem();

  //load the svg's
  loadSVGs();
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DRAW –––––––––––––––––––––

public void draw() {

  // Check for new files in data folder
  checkFiles();

  background(bgColor);

  // // display debug joystick state icon
  // if (true) {
  //   displayJoystickState();
  // }

  //test line game
  lineGameTest(width/2, height/2, 300, color(235,235,235));

  // get the input of gamepad and keyboard buttons and joysticks to control the graphic items
  getControllerInput();

  // update power move functionality if mode is active
  if (powerMoveMode) {
    updatePowerMoveMode();
  }

  // display all items
  for (int i = 0; i < myItems.size(); i++) {
    myItems.get(i).update();
    myItems.get(i).display();
    blendMode(BLEND);
  }

  // display power move interface if active
  if (powerMoveMode) {
    displayPowerMoveMode();
  }

  // set the activity alpha value for inactive items based on the last activity
  setActivityAlpha();
}

// ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

/*
 This tab stores the gamepad input functions for the specific buttons and joysticks.
 Everytime a button is released its own input function is triggered.
 The button input functions map and customize the input to the programs main functions ('GraphicItemControlFunctions').
 Various functions can be positioned on one button by using button combinations (like Button X pressed)
 FEEL FREE to configure the input functions to trigger the various functions you find in the 'GraphicItemControlFunctions' tab.
 */

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– FIXED VARIABLES ––––––––––

float LX, LY, RX, RY;
boolean hatLeftPressed, hatRightPressed, hatUpPressed, hatDownPressed, crossPressed, squarePressed, trianglePressed, circlePressed,
  sharePressed, optionsPressed, psPressed, touchpadPressed, L1Pressed, L2Pressed, L3Pressed, R1Pressed, R2Pressed, R3Pressed,
  LXPlusPressed, LXMinusPressed, LYPlusPressed, LYMinusPressed, RXPlusPressed, RXMinusPressed, RYPlusPressed, RYMinusPressed;

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– LEFT JOYSTICK ––––––––––––

public void joystickLeft(float x, float y) {
  if (x > 0.05f || x < -0.05f || y > 0.05f || y < -0.05f) {
    if (L2Pressed == true) {
      moveOnGrid(x, y);
    } else {
      move(x, y);
    }
  } else {
    if (interfaceSound == true) {
      endSound("move");
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– RIGHT JOYSTICK –––––––––––

// insert your own code here

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– RIGHT JOYSTICK –––––––––––

public void joystickRight(float x, float y) {
  if ((x > 0.1f || x < -0.1f) && abs(x) > abs(y)) {
    if (L2Pressed == true) {
      setRotationOnGrid(x);
    } else {
      setRotation(x);
    }
  } else {
    if (interfaceSound == true) {
      endSound("rotate");
    }
  }
  if ((y > 0.1f || y < -0.1f) && abs(y) > abs(x)) {
    if (L2Pressed == true) {
      setScaleOnGrid(y);
    } else {
      setScale(y);
    }
  } else {
    if (interfaceSound == true) {
      endSound("scale");
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– HAT UP –––––––––––––––––––

public void buttonUpRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Up");
  } else {
    if (powerMoveMode == true && moveMode == true && powerMove == "repetition") {
      setYRepetitionPlus();
    } else if (powerMoveMode == true && moveMode == true && powerMove == "animation") {
      setAnimationSpeedPlus();
    } else {
      if (R2Pressed == true) {
        if (powerMoveMode == false) {
          reorderItemForward();
        }
      } else if (L2Pressed == true) {
        setBackgroundColorToNext();
      } else {
        setItemColorToNext();
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– HAT DOWN –––––––––––––––––

public void buttonDownRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Down");
  } else {
    if (powerMoveMode == true && moveMode == true && powerMove == "repetition") {
      setYRepetitionMinus();
    } else if (powerMoveMode == true && moveMode == true && powerMove == "animation") {
      setAnimationSpeedMinus();
    } else {
      if (R2Pressed == true) {
        if (powerMoveMode == false) {
          reorderItemBackward();
        }
      } else if (L2Pressed == true) {
        setBackgroundColorToPrevious();
      } else {
        setItemColorToPrevious();
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– HAT LEFT –––––––––––––––––

public void buttonLeftRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Left");
  } else {
    if (powerMoveMode == true && moveMode == true && powerMove == "repetition") {
      setXRepetitionMinus();
    } else {
      if (R2Pressed == true) {
        if (powerMoveMode == false) {
          setPreviousAsActive();
        }
      } else {
        switch(activeItem.type) {
        case "font":
          if (L2Pressed == true) {
            deleteLetter();
          } else {
            switchLetterToPrevious();
          }
          break;
        case "image":
          break;
        case "vector":
          setStrokeWeightMinus();
          break;
        case "cam":
          break;
        }
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– HAT RIGHT ––––––––––––––––

public void buttonRightRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Right");
  } else {
    if (powerMoveMode == true && moveMode == true && powerMove == "repetition") {
      setXRepetitionPlus();
    } else {
      if (R2Pressed == true) {
        if (powerMoveMode == false) {
          setNextAsActive();
        }
      } else {
        switch(activeItem.type) {
        case "font":
          if (L2Pressed == true) {
            addLetter();
          } else {
            switchLetterToNext();
          }
          break;
        case "image":
          break;
        case "vector":
          setStrokeWeightPlus();
          break;
        case "cam":
          break;
        }
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– TRIANGLE -––––––––––––––––

public void buttonTriangleRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Triangle");
  } else {
    if (powerMoveMode == false) {
      if (L2Pressed == true) {
        setupAllItemsRandom();
      } else {
        setupRandom();
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SQUARE -––––––––––––––––––

public void buttonSquareRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Square");
  } else if (powerMoveMode == true && moveMode == true) {
    deletePowerMove();
  } else {
    deleteItem();
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– CIRCLE -––––––––––––––––––

public void buttonCircleRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Circle");
  } else {
    switchBlendMode();
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– CROSS –––-––––––––––––––––

public void buttonCrossRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Cross");
  } else if (powerMoveMode == true && moveMode == true) {
    confirmPowerMove();
  } else {
    addItem();
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– L1 –––––––––––––––––––––––

public void buttonL1Release() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("L1");
  } else {
    if (powerMoveMode == false) {
      switchGraphicFileToPrevious();
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– L2 –––––––––––––––––––––––

public void buttonL2Release() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("L2");
  } else {
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– L3 Joystick -–––––––––––––

public void buttonL3Release() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("L3");
  } else {
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– R1 –––––––––––––––––––––––

public void buttonR1Release() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("R1");
  } else {
    if (powerMoveMode == false) {
      switchGraphicFileToNext();
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– R2 –––––––––––––––––––––––

public void buttonR2Release() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("R2");
  } else {
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– R3 Joystick -–––––––––––––

public void buttonR3Release() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("R3");
  } else {
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SHARE ––––––––––––––––––––

public void buttonShareRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Share");
  } else {
    switch(activeItem.type) {
    case "font":
      setFontStyle();
      break;
    case "image":
      switchImageMode_AlphaOnOrOff();
      break;
    case "vector":
      switchVectorMode_FillOrStroke();
      break;
    case "cam":
      switchCamMode_LiveOrShot();
      break;
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– OPTIONS ––––––––––––––––––

public void buttonOptionsRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Options");
  } else {
    if (L2Pressed == true) {
      switchBackgroundSound();
    } else {
      switchInterfaceSound();
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– TOUCHPAD –––––––––––––––––

public void buttonTouchpadRelease() {
  if (powerMoveMode == true) {
    quitPowerMoveMode();
  } else {
    activatePowerMoveMode();
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– PS-BUTTON ––––––––––––––––

public void buttonPSRelease() {
  if (powerMoveMode == true && comboMode == true) {
    addButtonToCombo("Ps");
  } else {
    if (L2Pressed == true) {
      reset();
    } else {
      export();
    }
  }
}

// ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

/*
 This tab stores the keyboard input functions for the specific buttons and joysticks.
 Everytime a button is released its own input function is triggered.
 The button input functions map and customize the input to the programs main functions ('GraphicItemControlFunctions').
 Various functions can be positioned on one button by using button combinations (like Button X pressed)
 FEEL FREE to configure the input functions to trigger the various functions you find in the 'GraphicItemControlFunctions' tab.
 */


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– FIXED VARIABLES ––––––––––

boolean tabPressed, shiftPressed, controlPressed, altPressed, upPressed, downPressed, leftPressed, rightPressed, cPressed, wPressed, aPressed, pPressed, lPressed, sPressed;

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– LEFT JOYSTICK ––––––––––––


public void keyUp() {
  if (pPressed == true && powerMoveMode == true && moveMode == true && powerMove == "repetition") {
    setYRepetitionPlus();
  } else if (aPressed == true && powerMoveMode == true && moveMode == true && powerMove == "animation") {
    setAnimationSpeedPlus();
  } else if (wPressed == true && activeItem.type == "vector") {
    setStrokeWeightPlus();
  } else if (cPressed == true) {
    setBackgroundColorToNext();
  } else if (shiftPressed == true && controlPressed == true && altPressed == true) {
    reorderItemForward();
  } else if (controlPressed == true && altPressed == true) {
    setScaleOnGrid(-1.25f);
  } else if (controlPressed == true) {
    setScale(-1);
  } else if (altPressed == true) {
    moveOnGrid(0, -1.25f);
  } else {
    move(0, -1);
  }
}

public void keyDown() {

  if (pPressed == true && powerMoveMode == true && moveMode == true && powerMove == "repetition") {
    setYRepetitionMinus();
  } else if (aPressed == true && powerMoveMode == true && moveMode == true && powerMove == "animation") {
    setAnimationSpeedMinus();
  } else if (wPressed == true && activeItem.type == "vector") {
    setStrokeWeightMinus();
  } else if (cPressed == true) {
    setBackgroundColorToPrevious();
  } else if (shiftPressed == true && controlPressed == true && altPressed == true) {
    reorderItemBackward();
  } else if (controlPressed == true && altPressed == true) {
    setScaleOnGrid(1.25f);
  } else if (controlPressed == true) {
    setScale(1);
  } else if (altPressed == true) {
    moveOnGrid(0, 1.25f);
  } else {
    move(0, 1);
  }
}

public void keyLeft() {
  if (pPressed == true && powerMoveMode == true && moveMode == true && powerMove == "repetition") {
    setXRepetitionMinus();
  } else if (cPressed == true) {
    setItemColorToPrevious();
  } else if (lPressed == true) {
    switchLetterToPrevious();
  } else if (shiftPressed == true && controlPressed == true && altPressed == true) {
    setPreviousAsActive();
  } else if (shiftPressed == true) {
    switchGraphicFileToPrevious();
  } else if (controlPressed == true && altPressed == true) {
    setRotationOnGrid(-1.25f);
  } else if (controlPressed == true) {
    setRotation(-1);
  } else if (altPressed == true) {
    moveOnGrid(-1.25f, 0);
  } else {
    move(-1, 0);
  }
}

public void keyRight() {
  if (pPressed == true && powerMoveMode == true && moveMode == true && powerMove == "repetition") {
    setXRepetitionPlus();
  } else if (cPressed == true) {
    setItemColorToNext();
  } else if (lPressed == true) {
    switchLetterToNext();
  } else if (shiftPressed == true && controlPressed == true && altPressed == true) {
    setNextAsActive();
  } else if (shiftPressed == true) {
    switchGraphicFileToNext();
  } else if (controlPressed == true && altPressed == true) {
    setRotationOnGrid(1.25f);
  } else if (controlPressed == true) {
    setRotation(1);
  } else if (altPressed == true) {
    moveOnGrid(1.25f, 0);
  } else {
    move(1, 0);
  }
}

public void keyR() {
  if (powerMoveMode == false) {
    if (shiftPressed == true && controlPressed == true && altPressed == true) {
      reset();
    } else if (altPressed == true) {
      setupAllItemsRandom();
    } else {
      setupRandom();
    }
  }
}

public void keyX() {
  switchBlendMode();
}

public void keyM() {
  if (activeItem.type == "image") {
    switchImageMode_AlphaOnOrOff();
  } else if (activeItem.type == "vector") {
    switchVectorMode_FillOrStroke();
  } else if (activeItem.type == "font") {
    setFontStyle();
  } else if (activeItem.type == "cam") {
    switchCamMode_LiveOrShot();
  }
}

public void keyEnter() {
  if (lPressed == true && activeItem.type == "font" ) {
    addLetter();
  } else if (powerMoveMode == false) {
    addItem();
  } else if (powerMoveMode == true) {
    confirmPowerMove();
  }
}

public void keyBackspace() {
  if (lPressed == true && activeItem.type == "font" ) {
    deleteLetter();
  } else if (powerMoveMode == false) {
    deleteItem();
  } else if (powerMoveMode == true) {
    deletePowerMove();
  }
}

public void keyTab() {
  if (powerMoveMode == true) {
    quitPowerMoveMode();
  } else {
    activatePowerMoveMode();
  }
}

public void keyE() {
  export();
}

public void keyS() {
  if (controlPressed == true) {
    switchBackgroundSound();
  } else {
    switchInterfaceSound();
  }
}

// !!! PLEASE DO NOT MODIFY THIS TAB !!! ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––– !!! PLEASE DO NOT MODIFY THIS TAB !!!

/*
  This tab contains essential configurations for the  gamepad interactivity.
 */


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– FIXED VARIABLES ––––––––––

ControlIO control;
Configuration config;
ControlDevice device;

ControlHat hat;
float hatX, hatY;

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SETUP ––––––––––––––––––––


public void setupController() {
  if (gamepad == true) {
    control = ControlIO.getInstance(this);
    device = control.getMatchedDevice("controller/PS_Controller_Setup");

    hat = device.getHat("HAT");
    hat.plug(this, "hatRelease", ControlIO.ON_RELEASE);
    device.getButton("SH").plug(this, "buttonShareRelease", ControlIO.ON_RELEASE);
    device.getButton("OP").plug(this, "buttonOptionsRelease", ControlIO.ON_RELEASE);
    device.getButton("TP").plug(this, "buttonTouchpadRelease", ControlIO.ON_RELEASE);
    device.getButton("PS").plug(this, "buttonPSRelease", ControlIO.ON_RELEASE);
    device.getButton("TR").plug(this, "buttonTriangleRelease", ControlIO.ON_RELEASE);
    device.getButton("SQ").plug(this, "buttonSquareRelease", ControlIO.ON_RELEASE);
    device.getButton("CI").plug(this, "buttonCircleRelease", ControlIO.ON_RELEASE);
    device.getButton("CR").plug(this, "buttonCrossRelease", ControlIO.ON_RELEASE);
    device.getButton("L1").plug(this, "buttonL1Release", ControlIO.ON_RELEASE);
    device.getButton("L2").plug(this, "buttonL2Release", ControlIO.ON_RELEASE);
    device.getButton("L3").plug(this, "buttonL3Release", ControlIO.ON_RELEASE);
    device.getButton("R1").plug(this, "buttonR1Release", ControlIO.ON_RELEASE);
    device.getButton("R2").plug(this, "buttonR2Release", ControlIO.ON_RELEASE);
    device.getButton("R3").plug(this, "buttonR3Release", ControlIO.ON_RELEASE);
  }
}
// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– GET INPUT ––––––––––––––––


public void getControllerInput() {
  if (gamepad == true) {
    getGamepadInput();
  }
  if (gamepadFallback == true) {
    getGamepadFallbackInput();
  }
  if (keyboardFallback == true) {
    getKeyboardFallbackInput();
  }
}

public void getGamepadInput() {
  hatLeftPressed = hat.left();
  hatRightPressed = hat.right();
  hatUpPressed = hat.up();
  hatDownPressed = hat.down();
  hatX = hat.getX();
  hatY = hat.getY();
  crossPressed = device.getButton("CR").pressed();
  squarePressed = device.getButton("SQ").pressed();
  trianglePressed = device.getButton("TR").pressed();
  circlePressed = device.getButton("CI").pressed();
  sharePressed = device.getButton("SH").pressed();
  optionsPressed = device.getButton("OP").pressed();
  psPressed = device.getButton("PS").pressed();
  touchpadPressed = device.getButton("TP").pressed();
  L1Pressed = device.getButton("L1").pressed();
  L2Pressed = device.getButton("L2").pressed();
  L3Pressed = device.getButton("L3").pressed();
  R1Pressed = device.getButton("R1").pressed();
  R2Pressed = device.getButton("R2").pressed();
  R3Pressed = device.getButton("R3").pressed();
  LX = map(device.getSlider("LX").getValue(), -1, 1, -1.0f, 1.0f);
  LY = map(device.getSlider("LY").getValue(), -1, 1, -1.0f, 1.0f);
  RX = map(device.getSlider("RX").getValue(), -1, 1, -1.0f, 1.0f);
  RY = map(device.getSlider("RY").getValue(), -1, 1, -1.0f, 1.0f);

  displayJoystickState();

  joystickLeft(LX, LY);
  joystickRight(RX, RY);
}

public void hatRelease(float x, float y) {
  if (hatUpPressed)    buttonUpRelease();
  if (hatDownPressed)  buttonDownRelease();
  if (hatLeftPressed)  buttonLeftRelease();
  if (hatRightPressed) buttonRightRelease();
}


public void getGamepadFallbackInput() {
  joystickLeft(LX, LY);
  joystickRight(RX, RY);
}

public void getKeyboardFallbackInput() {
  if (cPressed == false && wPressed == false && shiftPressed == false && aPressed == false && pPressed == false && lPressed == false && sPressed == false) {
    if (upPressed == true) {
      keyUp();
    }
    if (downPressed == true) {
      keyDown();
    }
    if (leftPressed == true) {
      keyLeft();
    }
    if (rightPressed == true) {
      keyRight();
    }
  }
}

public void keyPressed() {

  if (gamepadFallback == true) {
    if (key == '4')               L3Pressed = true;
    if (key == 'h' || key == 'H') L2Pressed = true;
    if (key == 't' || key == 'T') L2Pressed = false;
    if (key == 'q' || key == 'Q') L1Pressed = true;
    if (key == '9')               R3Pressed = true;
    if (key == 'f' || key == 'F') R2Pressed = true;
    if (key == 'z' || key == 'Z') R2Pressed = false;
    if (key == 'd' || key == 'D') R1Pressed = true;
    if (key == 'g' || key == 'G') sharePressed = true;
    if (key == 'o' || key == 'O') optionsPressed = true;
    if (key == 'u' || key == 'U') touchpadPressed = true;
    if (key == 'p' || key == 'P') psPressed = true;
    if (key == 'y' || key == 'Y') trianglePressed = true;
    if (key == 'b' || key == 'B') circlePressed = true;
    if (key == 'a' || key == 'A') crossPressed = true;
    if (key == 'i' || key == 'I') squarePressed = true;
    if (key == 'j' || key == 'J') hatUpPressed = true;
    if (key == 'k' || key == 'K') hatDownPressed = true;
    if (key == 'v' || key == 'V') hatLeftPressed = true;
    if (key == 'n' || key == 'N') hatRightPressed = true;
    if (key == '0')               LYPlusPressed = true;
    if (key == '1')               LXPlusPressed = true;
    if (key == '2')               LYMinusPressed = true;
    if (key == '3')               LXMinusPressed = true;
    if (key == '5')               RYPlusPressed = true;
    if (key == '6')               RXPlusPressed = true;
    if (key == '7')               RYMinusPressed = true;
    if (key == '8')               RXMinusPressed = true;

    if (key == '0')               LY = -1;
    if (key == '1')               LX = 1;
    if (key == '2')               LY = 1;
    if (key == '3')               LX = -1;
    if (key == '5')               RY = -1;
    if (key == '6')               RX = 1;
    if (key == '7')               RY = 1;
    if (key == '8')               RX = -1;

    if (key == 't' || key == 'T') buttonL2Release();
    if (key == 'z' || key == 'Z') buttonR2Release();
  }

  if (keyboardFallback == true) {
    if (keyCode == TAB) tabPressed = true;
    if (keyCode == SHIFT) shiftPressed = true;
    if (keyCode == CONTROL) controlPressed = true;
    if (keyCode == ALT) altPressed = true;
    if (keyCode == UP) upPressed = true;
    if (keyCode == DOWN) downPressed = true;
    if (keyCode == LEFT) leftPressed = true;
    if (keyCode == RIGHT) rightPressed = true;
    if (key == 'c' || key == 'C') cPressed = true;
    if (key == 'w' || key == 'W') wPressed = true;
    if (key == 'a' || key == 'A') aPressed = true;
    if (key == 'p' || key == 'P') pPressed = true;
    if (key == 'l' || key == 'L') lPressed = true;
    if (key == 's' || key == 'S') sPressed = true;
  }
}


public void keyReleased() {

  if (gamepadFallback == true) {
    if (key == '4')               L3Pressed = false;
    if (key == 'h' || key == 'H') L2Pressed = false;
    if (key == 't' || key == 'T') L2Pressed = true;
    if (key == 'q' || key == 'Q') L1Pressed = false;
    if (key == '9')               R3Pressed = false;
    if (key == 'f' || key == 'F') R2Pressed = false;
    if (key == 'z' || key == 'Z') R2Pressed = true;
    if (key == 'd' || key == 'D') R1Pressed = false;
    if (key == 'g' || key == 'G') sharePressed = false;
    if (key == 'o' || key == 'O') optionsPressed = false;
    if (key == 'u' || key == 'U') touchpadPressed = false;
    if (key == 'p' || key == 'P') psPressed = false;
    if (key == 'y' || key == 'Y') trianglePressed = false;
    if (key == 'b' || key == 'B') circlePressed = false;
    if (key == 'a' || key == 'A') crossPressed = false;
    if (key == 'i' || key == 'I') squarePressed = false;
    if (key == 'j' || key == 'J') hatUpPressed = true;
    if (key == 'k' || key == 'K') hatDownPressed = true;
    if (key == 'v' || key == 'V') hatLeftPressed = true;
    if (key == 'n' || key == 'N') hatRightPressed = true;
    if (key == '0')               LYPlusPressed = true;
    if (key == '1')               LXPlusPressed = true;
    if (key == '2')               LYMinusPressed = true;
    if (key == '3')               LXMinusPressed = true;
    if (key == '5')               RYPlusPressed = true;
    if (key == '6')               RXPlusPressed = true;
    if (key == '7')               RYMinusPressed = true;
    if (key == '8')               RXMinusPressed = true;

    if (key == '4')               buttonL3Release();
    if (key == 'h' || key == 'H') buttonL2Release();
    if (key == 'q' || key == 'Q') buttonL1Release();
    if (key == '9')               buttonR3Release();
    if (key == 'f' || key == 'F') buttonR2Release();
    if (key == 'd' || key == 'D') buttonR1Release();
    if (key == 'g' || key == 'G') buttonShareRelease();
    if (key == 'o' || key == 'O') buttonOptionsRelease();
    if (key == 'u' || key == 'U') buttonTouchpadRelease();
    if (key == 'p' || key == 'P') buttonPSRelease();
    if (key == 'y' || key == 'Y') buttonTriangleRelease();
    if (key == 'b' || key == 'B') buttonCircleRelease();
    if (key == 'a' || key == 'A') buttonCrossRelease();
    if (key == 'i' || key == 'I') buttonSquareRelease();
    if (key == 'j' || key == 'J') buttonUpRelease();
    if (key == 'k' || key == 'K') buttonDownRelease();
    if (key == 'v' || key == 'V') buttonLeftRelease();
    if (key == 'n' || key == 'N') buttonRightRelease();

    if (key == '0')               LY = 0;
    if (key == '1')               LX = 0;
    if (key == '2')               LY = 0;
    if (key == '3')               LX = 0;
    if (key == '5')               RY = 0;
    if (key == '6')               RX = 0;
    if (key == '7')               RY = 0;
    if (key == '8')               RX = 0;
  }


  if (keyboardFallback == true) {
    if (keyCode == TAB)            tabPressed = false;
    if (keyCode == SHIFT)          shiftPressed = false;
    if (keyCode == CONTROL)        controlPressed = false;
    if (keyCode == ALT)            altPressed = false;
    if (keyCode == UP)             upPressed = false;
    if (keyCode == DOWN)           downPressed = false;
    if (keyCode == LEFT)           leftPressed = false;
    if (keyCode == RIGHT)          rightPressed = false;
    if (key == 'c' || key == 'C')  cPressed = false;
    if (key == 'w' || key == 'W')  wPressed = false;
    if (key == 'a' || key == 'A')  aPressed = false;
    if (key == 'p' || key == 'P')  pPressed = false;
    if (key == 'l' || key == 'L')  lPressed = false;
    if (key == 's' || key == 'S')  sPressed = false;

    if (keyCode == TAB)            keyTab();
    if (keyCode == UP)             keyUp();
    if (keyCode == DOWN)           keyDown();
    if (keyCode == LEFT)           keyLeft();
    if (keyCode == RIGHT)          keyRight();
    if (keyCode == BACKSPACE)      keyBackspace();
    if (keyCode == ENTER)          keyEnter();
    if (key == 'r' || key == 'R')  keyR();
    if (key == 'x' || key == 'X')  keyX();
    if (key == 'm' || key == 'M')  keyM();
    if (key == 'e' || key == 'E')  keyE();
    if (key == 's' || key == 'S')  keyS();

    if (powerMoveMode == true && comboMode == true && comboKeys.contains(""+key) && gamepadFallback == false) {
      addButtonToCombo(""+key);
    }

    if (interfaceSound == true) {
      if (leftPressed == false && rightPressed == false) {
        endSound("rotate");
      }
      if (upPressed == false && downPressed == false) {
        endSound("scale");
      }
      if (leftPressed == false && rightPressed == false && upPressed == false && downPressed == false) {
        endSound("move");
      }
    }
  }

  keyCode = -1;
}
//import svg 
PShape M_Path;

public void loadSVGs() {
    // M_Path = loadShape("data/game/M_Path.svg");
}

public void lineGameTest(float x, float y, int scaleSize, int c) {
//     //make an M letter with lines
    // push();
       
    //     shape(M_Path, x, y);
    
    // pop();
    
    // if (M_Path.contains(activeItem.position.x, activeItem.position.y)) {
    //     circle(200,200,50);
    // }
}

// !!! PLEASE DO NOT MODIFY THIS TAB !!! ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––– !!! PLEASE DO NOT MODIFY THIS TAB !!!

/*
 This tab contains the essential functions related to displaying the graphic items.
 The Graphic Item Class serves as a framework for managing various types of graphic items
 with a specific set of configurable variables.
 The subclasses for image, vector font and cam items are adapted for the visual integration.
 */


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– GLOBAL –––––––––––––––––––

class GraphicItem {

  boolean active = false;
  float size = min(width, height)/4;
  String type;
  File file;
  int fileIndex;

  PVector position = new PVector(width/2, height/2);
  float scale = 1.0f;
  float rotation = 0;

  int colIndex = 0;
  int col = myColors[colIndex];

  int blendModeIndex = 0;
  int blendMode = blendModes[blendModeIndex];
  boolean randomSet = false;


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ITEM SPECIFIC ––––––––––––––

  // Image Item
  PImage img;
  PImage imgDefault;
  PImage[] imgDuplex = new PImage[myColors.length];
  PImage[] imgDuplexAlpha = new PImage[myColors.length];
  boolean defaultColor = true;
  boolean imageModeAlpha = false;

  // Vector Item
  PShape shape;
  boolean vectorModeStroke = false;
  float strokeWeight = strokeWeightDefault;

  // Font Item
  PFont[] fontFamily;
  int fontFamilyIndex = 0;
  int activeCharIndex = 0;
  String text = "" + characterSet[activeCharIndex];

  // Cam Item
  Capture cam;
  boolean camModeLive = false;


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVES ––––––––––––––––

  // Drawing
  PGraphics imgDrawing;
  Boolean drawing = false;
  boolean drawingDelete = false;
  Boolean drawingSetup = false;
  PVector drawingCornerTopLeft = new PVector(0, 0);
  PVector drawingCornerBottomRight = new PVector(0, 0);
  PVector drawingCenter = new PVector(0, 0);
  PVector drawingPosition = new PVector(0, 0);
  float drawingScale = 0.0f;
  float drawingRotation = 0;

  // Animation
  boolean animation = false;
  float animationSpeed = animationSpeedDefault;
  float animationRestXPos = 0;
  float animationRestYPos = 0;
  float animationRestRot = 0;
  float animationRestSca = 0;
  float animationTransXPos = 0;
  float animationTransYPos = 0;
  float animationTransRot = 0;
  float animationTransSca = 0;

  // Repetition
  boolean repetition = false;
  PVector repetitionPosition = new PVector(0, 0);
  PVector repetitionDirection = new PVector(0, 0);
  PVector repetitions = new PVector(1, 1);



  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– CONSTRUCTOR ––––––––––––––––

  GraphicItem (String t, File f, int fI) {
    type = t;
    file = f;
    fileIndex = fI;
    println("Loaded: " + file);
  }

  GraphicItem (GraphicItem item) {
    type = item.type;
    file = item.file;
    fileIndex = item.fileIndex;
  }

  GraphicItem () {
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– UPDATE –––––––––––––––––––––

  public void update() {
    if (drawingDelete == true) {
      drawingDelete = false;
      deleteDrawing();
    }
    if (randomSet == true) {
      randomReset(this);
      randomSet = false;
    }
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DISPLAY ––––––––––––––––––––

  public void display() {
    pushMatrix();
    blendMode(blendMode);
    if (drawing == true) {
      displayDrawing();
    } else {
      translate(position.x, position.y);
      rotate(radians(rotation));
      scale(scale);
      if (animation) animate();
      if (repetition) {
        for (float xRepetition = PApplet.parseInt(repetitions.x)*-0.5f; xRepetition <= repetitions.x*0.5f; xRepetition++) {
          for (float yRepetition = PApplet.parseInt(repetitions.y)*-0.5f; yRepetition <= repetitions.y*0.5f; yRepetition++) {
            float x = lerp(0, repetitionDirection.x * repetitions.x, xRepetition*(1.0f/repetitions.x));
            float y = lerp(0, repetitionDirection.y * repetitions.y, yRepetition*(1.0f/repetitions.y));
            displayItemSpecific(x, y);
          }
        }
      } else {
        displayItemSpecific(0, 0);
      }
    }
    popMatrix();
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– PRINT ––––––––––––––––––––––

  public void printCanvas(PGraphics c, float s) {
    c.pushMatrix();
    c.imageMode(CENTER);
    c.blendMode(BLEND);
    if (drawing == true) {
      PGraphics d = createGraphics(width, height);
      d.beginDraw();
      d.pushMatrix();
      d.translate(drawingCenter.x+(position.x-drawingPosition.x), drawingCenter.y+(position.y-drawingPosition.y));
      d.rotate(radians(rotation-drawingRotation));
      d.scale(constrain(scale-drawingScale+1.0f, scaleMin, scaleMax));
      d.translate(-drawingCenter.x+width/2, -drawingCenter.y+height/2);
      d.imageMode(CENTER);
      d.image(imgDrawing, 0, 0);
      d.popMatrix();
      d.endDraw();
      c.image(d, c.width/2, c.height/2, c.width, c.height);
    } else {
      c.translate(map(position.x, 0, width, 0, c.width), map(position.y, 0, height, 0, c.height));
      c.scale(scale*s);
      c.rotate(radians(rotation));
      drawItemSpecific(0, 0, c);
    }
    c.popMatrix();
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– COPY –––––––––––––––––––––––

  public void copyValues(GraphicItem prevItem) {
    position.set(prevItem.position.x, prevItem.position.y);
    scale = prevItem.scale;
    rotation = prevItem.rotation;

    colIndex = prevItem.colIndex;
    col = myColors[colIndex];
    defaultColor = prevItem.defaultColor;
    imageModeAlpha = prevItem.imageModeAlpha;
    blendMode = prevItem.blendMode;
    blendModeIndex = prevItem.blendModeIndex;

    activeCharIndex = prevItem.activeCharIndex;
    if (prevItem.text != null) {
      text = prevItem.text;
    } else {
      text = "" + characterSet[activeCharIndex];
    }

    vectorModeStroke = prevItem.vectorModeStroke;
    strokeWeight = prevItem.strokeWeight;

    if (type == "image") {
      updateImg();
    }
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DUPLEX –––––––––––––––––––––

  public PImage createColorImage(PImage img1, int col1, boolean alpha) {
    PImage img2 = createImage(img1.width, img1.height, ARGB);
    int pixelColor;
    for (int i = 0; i < img1.pixels.length; i++) {
      float alphaS = map(saturation(img1.pixels[i]), 0.0f, 255.0f, 0.0f, 255.0f);
      float alphaB = map(brightness(img1.pixels[i]), 0.0f, 255.0f, 255.0f, 0.0f);
      if (alpha) {
        pixelColor = color(red(col1), green(col1), blue(col1), max(alphaS, alphaB));
      } else {
        pixelColor = lerpColor(color(255), col1, max(alphaS, alphaB)/255);
      }
      img2.pixels[i] = pixelColor;
    }
    return img2;
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVE: DRAWING ––––––––

  // Power Move: Drawing ––––––––––––––––––

  public void updateDrawing() {
    if (drawingSetup == false) {
      setupDrawing();
    }

    imgDrawing.beginDraw();
    imgDrawing.pushMatrix();
    imgDrawing.translate(position.x-((width-imgDrawing.width)/2), position.y-((height-imgDrawing.height)/2));
    imgDrawing.scale(scale);
    imgDrawing.rotate(radians(rotation));
    drawItemSpecific(0, 0, imgDrawing);
    imgDrawing.popMatrix();
    imgDrawing.endDraw();

    drawingCornerTopLeft.set(min(position.x, drawingCornerTopLeft.x), min(position.y, drawingCornerTopLeft.y));
    drawingCornerBottomRight.set(max(position.x, drawingCornerBottomRight.x), max(position.y, drawingCornerBottomRight.y));
    float centerX = ((drawingCornerBottomRight.x-drawingCornerTopLeft.x)/2)+drawingCornerTopLeft.x;
    float centerY = ((drawingCornerBottomRight.y-drawingCornerTopLeft.y)/2)+drawingCornerTopLeft.y;
    drawingCenter.set(centerX, centerY);
    drawingPosition.set(position.x, position.y);
    drawingScale = scale;
    drawingRotation = rotation;
  }

  public void displayDrawing() {

    if (powerMoveMode == false) drawingSetup = false;
    translate(drawingCenter.x+(position.x-drawingPosition.x), drawingCenter.y+(position.y-drawingPosition.y));
    rotate(radians(rotation-drawingRotation));
    scale(constrain(scale-drawingScale+1.0f, scaleMin, scaleMax));
    if (animation == true) animate();
    translate(-drawingCenter.x+width/2, -drawingCenter.y+height/2);
    if (active == false) tint(white, PApplet.parseInt(map(alphaInactivity, 0.0f, 1.0f, 0, 255)));
    image(imgDrawing, 0, 0);
    noTint();
  }

  public void setupDrawing() {
    imgDrawing = createGraphics(PApplet.parseInt(width*2), PApplet.parseInt(height*2));
    drawingCornerTopLeft.set(position.x, position.y);
    drawingCornerBottomRight.set(position.x, position.y);

    drawingSetup = true;
    drawing = true;
  }

  public void deleteDrawing() {
    imgDrawing = createGraphics(PApplet.parseInt(width*2), PApplet.parseInt(height*2));
    drawingCornerTopLeft.set(0, 0);
    drawingCornerBottomRight.set(0, 0);
    drawingCenter.set(0, 0);
    drawingPosition.set(0, 0);
    drawing = false;
    drawingSetup = false;
  }

  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVE: ANIMATION ––––––

  public void animate() {

    float [] updatedValues = updateAnimationValues(this);

    translate(updatedValues[0], updatedValues[1]);
    rotate(radians(updatedValues[2]));
    scale(1.0f+updatedValues[3]);
  }

  public void updateAnimation() {
    if (animation == false) {
      setupAnimation();
    }

    animationTransXPos = position.x-animationRestXPos;
    animationTransYPos = position.y-animationRestYPos;
    animationTransRot = rotation-animationRestRot;
    animationTransSca = scale-animationRestSca;
  }

  public void setupAnimation () {
    animationRestXPos = position.x;
    animationRestYPos = position.y;
    animationRestRot = rotation;
    animationRestSca = scale;

    animation = true;
  }

  public void resetAnimation() {
    animation = false;
    animationSpeed = animationSpeedDefault;
    animationRestXPos = 0;
    animationRestYPos = 0;
    animationRestRot = 0;
    animationRestSca = 0;
    animationTransXPos = 0;
    animationTransYPos = 0;
    animationTransRot = 0;
    animationTransSca = 0;
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVE: REPETITION –––––

  public void setupRepetition() {
    repetitionPosition.set(position.x+size, position.y+size);
    repetition = true;
  }

  public void updateRepetition() {
    if (repetition == false) setupRepetition();
    repetitionDirection.set(position.x-repetitionPosition.x, position.y - repetitionPosition.y);
  }


  // –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––

  public void displayItemSpecific(float x, float y) {
  }
  public void drawItemSpecific(float x, float y, PGraphics canvas) {
  }
  public void updateImg() {
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SUBCLASS: IMAGE ––––––––––––

class imgItem extends GraphicItem {

  imgItem (String t, File f, int fI) {
    super(t, f, fI);
    defaultColor = true;

    imgDefault = loadImage(""+f);
    for (int i = 0; i < myColors.length; i++) {
      imgDuplex[i] = createColorImage(imgDefault, myColors[i], false);
      imgDuplexAlpha[i] = createColorImage(imgDefault, myColors[i], true);
    }
    updateImg();
  }

  imgItem (GraphicItem item) {
    super(item);
    img = item.img.copy();
    imgDefault = item.imgDefault.copy();
    for (int i = 0; i < item.imgDuplex.length; i++) {
      imgDuplex[i] = item.imgDuplex[i].copy();
      imgDuplexAlpha[i] = item.imgDuplexAlpha[i].copy();
    }
  }

  public void displayItemSpecific(float x, float y) {
    if (active == false) tint(white, PApplet.parseInt(map(alphaInactivity, 0.0f, 1.0f, 0, 255)));
    image (img, x, y, (size/img.height)*img.width, size);
    noTint();
  }

  public void drawItemSpecific(float x, float y, PGraphics canvas) {
    canvas.imageMode(CENTER);
    canvas.image(img, x, y, (size/img.height)*img.width, size);
    canvas.noTint();
  }

  public void updateImg() {
    if (defaultColor == true)     img = imgDefault;
    else {
      if (imageModeAlpha == true) img = imgDuplexAlpha[colIndex];
      else                        img = imgDuplex[colIndex];
    }
  }
}

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SUBCLASS: VECTOR –––––––––––

class vectorItem extends GraphicItem {

  vectorItem (String t, File f, int fI) {
    super(t, f, fI);
    shape = loadShape(""+f);
  }

  vectorItem (GraphicItem item) {
    super(item);
    shape = item.shape;
  }

  public void displayItemSpecific(float x, float y) {
    shape.disableStyle();

    if (vectorModeStroke == true) {
      if (active == true) stroke(col);
      else                stroke(lerpColor(white, col, alphaInactivity));
      strokeWeight(strokeWeight);
      noFill();
    } else {
      if (active == true) fill(col);
      else                fill(lerpColor(white, col, alphaInactivity));
      noStroke();
    }

    shape(shape, x, y, size, size);
  }

  public void drawItemSpecific(float x, float y, PGraphics canvas) {
    shape.disableStyle();
    canvas.shapeMode(CENTER);
    if (vectorModeStroke == true) {
      canvas.stroke(col);
      canvas.strokeWeight(strokeWeight);
      canvas.noFill();
    } else {
      canvas.fill(col);
      canvas.noStroke();
    }
    canvas.shape(shape, x, y, size, size);
  }
}

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SUBCLASS: FONT –––––––––––––

class fontItem extends GraphicItem {

  fontItem (String t, File f, int fI) {
    super(t, f, fI);

    // Check if font is a font family or single font
    if (match(""+f, "_otf") != null) {

      File fontFolder =  new File(dataPath("" + f));
      File [] fontFiles = fontFolder.listFiles();

      String [] fontFilesSorted = new String [0];
      for (int i = 0; i<fontFiles.length; i++) {
        File tempFontFile = fontFiles[i];
        if (match(""+tempFontFile, "\\.otf") != null) {
          fontFilesSorted = append(fontFilesSorted, ""+tempFontFile);
        }
      }
      fontFilesSorted = sort(fontFilesSorted);
      fontFamily = new PFont[fontFilesSorted.length];

      for (int i = 0; i<fontFilesSorted.length; i++) {
        File tempFontFile =  new File(dataPath("" + fontFilesSorted[i]));

        if (match(""+tempFontFile, "\\.otf") != null) {
          fontFamily[i] = createFont(""+tempFontFile, size);
          println("Loaded: " + tempFontFile);
        }
      }
    } else {
      fontFamily = new PFont[1];
      fontFamily[0] = createFont(""+f, size);
    }
  }

  fontItem (GraphicItem item) {
    super(item);
    fontFamily = item.fontFamily;
    fontFamilyIndex= item.fontFamilyIndex;
  }

  public void displayItemSpecific(float x, float y) {
    textFont(fontFamily[fontFamilyIndex]);
    textAlign(CENTER);
    if (active == true) fill(col);
    else                fill(lerpColor(white, col, alphaInactivity));
    noStroke();

    if (fontFamily[fontFamilyIndex].getGlyph(text.charAt(0)) != null) {
      float textHeight = fontFamily[fontFamilyIndex].getGlyph(text.charAt(0)).height;
      text(text, x, y + textHeight/2);
    } else {
      text(text, x, y + size*0.35f);
    }
  }

  public void drawItemSpecific(float x, float y, PGraphics canvas) {
    canvas.textFont(fontFamily[fontFamilyIndex]);
    canvas.textAlign(CENTER);
    canvas.fill(col);
    canvas.noStroke();
    canvas.text(text, x, y+fontFamily[fontFamilyIndex].getGlyph(text.charAt(0)).height/2);
  }
}

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SUBCLASS: CAMERA -––––––––––

class camItem extends GraphicItem {

  camItem (PApplet main) {
    type = "cam";
    String[] cameras = Capture.list();
    println("\nAvailable Cameras: ");
    printArray(cameras);
    cam = new Capture(main, 1920/2, 1080/2, cameras[cameraIndex], 25);
    cam.start();
    camModeLive = true;
    defaultColor = true;
  }

  camItem (GraphicItem item) {
    super(item);
    cam = item.cam;
    if (item.type == "cam") camModeLive = item.camModeLive;
    if (item.img != null) img = item.img.copy();
    if (item.imgDefault != null) imgDefault = item.imgDefault.copy();
    for (int i = 0; i < item.imgDuplex.length; i++) {
      if (item.imgDuplex[i] != null) {
        imgDuplex[i] = item.imgDuplex[i].copy();
      }
    }
  }

  public void displayItemSpecific(float x, float y) {
    if (cam.available() == true) cam.read();
    if (active == false) tint(white, PApplet.parseInt(map(alphaInactivity, 0.0f, 1.0f, 0, 255)));
    if (camModeLive == false && img != null)  image(img, x, y, (size/img.height)*img.width, size);
    else                                      image(cam.copy(), x, y, (size/cam.height)*cam.width, size);
    noTint();
  }

  public void drawItemSpecific(float x, float y, PGraphics canvas) {
    canvas.imageMode(CENTER);
    if (cam.available() == true) cam.read();
    if (camModeLive == false) canvas.image(img, x, y, (size/img.height)*img.width, size);
    else                      canvas.image(cam, x, y, (size/cam.height)*cam.width, size);
  }

  public void updateImg() {
    if (camModeLive == false) {
      if (defaultColor == true) img = imgDefault;
      else                      img = imgDuplex[colIndex];
    }
  }
}

// ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

/*
 This tab stores all the essential functions related to interacting with the graphic items.
 FEEL FREE TO MODIFY THE CODE to experiment with the functions and variables.
 */


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– MOVE –––––––––––––––––––––

// MODIFIED VARIABLES
// PVector  activeItem.position

// EDITABLE VARIABLES
float margin = -5;
float moveSpeed = 10;
int  horizontalGridSize = 50;
int  verticalGridSize = 50;

public void move(float xInput, float yInput) {

  // map input values to get the x/yDirection
  float xDirection = map(xInput, -1.0f, 1.0f, -moveSpeed, moveSpeed);
  float yDirection = map(yInput, -1.0f, 1.0f, -moveSpeed, moveSpeed);

  // add x/yDirection to current position
  activeItem.position.x = activeItem.position.x + xDirection;
  activeItem.position.y = activeItem.position.y + yDirection;

  // constrain position to frame margin
  activeItem.position.x = constrain(activeItem.position.x, margin, width-margin);
  activeItem.position.y = constrain(activeItem.position.y, margin, height-margin);

  // play sound of this function
  if (interfaceSound == true) {
    playSound("move", activeItem.position.y);
  }
}

public void moveOnGrid(float xInput, float yInput) {

  // map input values and add it to the inputx/yDirection (sum of previous move inputs)
  xInputDirection += map(xInput, -1.0f, 1.0f, -horizontalGridSize/gridSpeed, horizontalGridSize/gridSpeed);
  yInputDirection += map(yInput, -1.0f, 1.0f, -verticalGridSize/gridSpeed, verticalGridSize/gridSpeed);

  // check if inputXDirection is beyond the horizontalGridSize
  if (abs(xInputDirection) > horizontalGridSize) {

    // if true add/subtract horizontalGridSize to current position
    if (xInputDirection > horizontalGridSize) {
      activeItem.position.x = activeItem.position.x + horizontalGridSize;
    } else if (xInputDirection < -horizontalGridSize) {
      activeItem.position.x = activeItem.position.x - horizontalGridSize;
    }

    // constrain position to frame margin
    activeItem.position.x = constrain(activeItem.position.x, margin, width-margin);

    // gridify position to horizontalGridSize
    activeItem.position.x = round(activeItem.position.x/horizontalGridSize)*horizontalGridSize;

    //reset inputXDirection
    xInputDirection = 0;
  }

  // check if inputYDirection is beyond the verticalGridSize
  if (abs(yInputDirection) > verticalGridSize) {

    // if true add/subtract verticalGridSize to current position
    if (yInputDirection > verticalGridSize) {
      activeItem.position.y = activeItem.position.y + verticalGridSize;
    } else if (yInputDirection < -verticalGridSize) {
      activeItem.position.y = activeItem.position.y - verticalGridSize;
    }

    // constrain position to frame margin
    activeItem.position.y = constrain(activeItem.position.y, margin, height-margin);

    // gridify position to verticalGridSize
    activeItem.position.y = round(activeItem.position.y / verticalGridSize) * verticalGridSize;

    //reset inputYDirection
    yInputDirection = 0;
  }

  // play sound of this function
  if (interfaceSound == true) {
    playSound("move", activeItem.position.y);
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SCALE ––––––––––––––––––––

// MODIFIED VARIABLES
// Float  activeItem.scale

// EDITABLE VARIABLES
float scaleMin = 0.25f;
float scaleMax = 10.0f;
float scaleSpeed = 0.1f;
float scaleGridSize = 1.0f;

public void setScale(float sInput) {

  // map input values to get the scaleInputDirection
  float sDirection = map(sInput, -1.0f, 1.0f, scaleSpeed, -scaleSpeed);

  // add scaleInputDirection to current scale
  activeItem.scale = activeItem.scale + sDirection;

  // constrain scale to minimum and maximum values
  activeItem.scale = constrain(activeItem.scale, scaleMin, scaleMax);

  if (interfaceSound == true) {
    playSound("scale", activeItem.scale);
  }
}

public void setScaleOnGrid(float sInput) {

  // map input values and add it to the scaleInputDirection (sum of previous scale inputs)
  sInputDirection += map(sInput, -1.0f, 1.0f, scaleGridSize/gridSpeed, -scaleGridSize/gridSpeed);

  // check if scaleInputDirection direction is beyond the scaleGridSize
  if (abs(sInputDirection) > scaleGridSize) {

    // if true add/subtract scaleGridSize to current scale
    if (sInputDirection > scaleGridSize) {
      activeItem.scale = activeItem.scale + scaleGridSize;
    } else if (sInputDirection < -scaleGridSize) {
      activeItem.scale = activeItem.scale - scaleGridSize;
    }

    // constrain scale to minimum and maximum values
    activeItem.scale = constrain(activeItem.scale, scaleMin, scaleMax);

    // gridify scale to scaleGridSize
    activeItem.scale = round(activeItem.scale / scaleGridSize) * scaleGridSize;

    //reset scaleInputDirection
    sInputDirection = 0;
  }

  // play sound of this function
  if (interfaceSound == true) {
    playSound("scale", activeItem.scale);
  }
}



// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ROTATION –––––––––––––––––

// MODIFIED VARIABLES
// Float  activeItem.rotation

// EDITABLE VARIABLES
float rotationMin = 0;
float rotationMax = 360;
float rotationSpeed = 2;
float rotationGridSize = 45;

public void setRotation(float rInput) {

  // map input values to get the rotationDirection
  float rDirection = map(rInput, -1.0f, 1.0f, -rotationSpeed, rotationSpeed);

  // add rotationDirection to current rotation
  activeItem.rotation = activeItem.rotation + rDirection;

  // constrain rotation to circle constant
  activeItem.rotation = activeItem.rotation%360;

  // play sound of this function
  if (interfaceSound == true) {
    playSound("rotate", activeItem.rotation);
  }
}

public void setRotationOnGrid(float rInput) {

  // map input value and add it to rotationInputDirection (sum of previous rotation inputs)
  rInputDirection += map(rInput, -1.0f, 1.0f, -rotationGridSize/gridSpeed, rotationGridSize/gridSpeed);

  // check if rotationInputDirection direction is beyond the rotationGridSize
  if (abs(rInputDirection) > rotationGridSize) {

    // if true add/subtract rotationGridSize to current rotation
    if (rInputDirection > rotationGridSize) {
      activeItem.rotation = activeItem.rotation + rotationGridSize;
    } else if (rInputDirection < -rotationGridSize) {
      activeItem.rotation = activeItem.rotation - rotationGridSize;
    }

    // constrain rotation to circle constant
    activeItem.rotation = activeItem.rotation%360;

    // gridify rotation to rotationGridSize
    activeItem.rotation = round(activeItem.rotation / rotationGridSize) * rotationGridSize;

    //reset rotationInputDirection
    rInputDirection = 0;
  }

  // play sound of this function
  if (interfaceSound == true) {
    playSound("rotate", activeItem.rotation);
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– LETTER –––––––––––––––––––

// MODIFIED VARIABLES
// String  activeItem.text             :  combining all previously added characters
// Int     activeItem.activeCharIndex  :  index of active char in characterSet
// Int     activeItem.fontFamilyIndex  :  index of fontstyle in fontFamily

// EDITABLE VARIABLES
// Set of characters that will be skipped through to set text
String [] characterSet = {"A", "a", "B", "b", "C", "c", "D", "d", "E", "e", "F", "f", "G", "g", "H", "h", "I", "i", "J", "j", "K", "k", "L", "l", "M", "m",
  "N", "n", "O", "o", "P", "p", "Q", "q", "R", "r", "S", "s", "T", "t", "U", "u", "V", "v", "W", "w", "X", "x", "Y", "y", "Z", "z", ".", ",", "?", "!"};
//String [] characterSet = {"A", "a", "B", "b", "C", "c", "D", "d", "E", "e", "F", "f", "G", "g", "H", "h", "I", "i", "J", "j", "K", "k", "L", "l", "M", "m",
//  "N", "n", "O", "o", "P", "p", "Q", "q", "R", "r", "S", "s", "T", "t", "U", "u", "V", "v", "W", "w", "X", "x", "Y", "y", "Z", "z"}
//  String [] characterSet = {"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
//  "1", "2", "3", "4", "5", "6", "7", "8", "9", "0", ".", ",", "?", "!"};

public void switchLetterToNext() {

  // trim text by its last entry
  activeItem.text = activeItem.text.substring(0, activeItem.text.length()-characterSet[activeItem.activeCharIndex].length());

  // increase activeCharIndex by one
  activeItem.activeCharIndex++;

  // if activeCharIndex exeeds total amount of characters in characterSet, then switch to the remainder
  activeItem.activeCharIndex = activeItem.activeCharIndex%characterSet.length;

  //  add the letter of activeCharIndex in characterSet to text
  activeItem.text = activeItem.text + characterSet[activeItem.activeCharIndex];

  // play sound of this function
  if (interfaceSound == true) {
    playSound("switch letter");
  }
}

public void switchLetterToPrevious() {

  // trim text by its last entry
  activeItem.text = activeItem.text.substring(0, activeItem.text.length()-characterSet[activeItem.activeCharIndex].length());

  // decrease activeCharIndex by one
  activeItem.activeCharIndex--;

  // if activeCharIndex goes below 0 then switch to the last index of characterSet
  if (activeItem.activeCharIndex < 0) {
    activeItem.activeCharIndex = characterSet.length-1;
  }

  // add the letter of activeCharIndex in characterSet to text
  activeItem.text = activeItem.text + characterSet[activeItem.activeCharIndex];

  // play sound of this function
  if (interfaceSound == true) {
    playSound("switch letter");
  }
}

public void addLetter() {

  // add the letter of activeCharIndex in characterSet to text
  activeItem.text = activeItem.text + characterSet[activeItem.activeCharIndex];

  // play sound of this function
  if (interfaceSound == true) {
    playSound("add letter");
  }
}

public void deleteLetter() {

  // only delete letters if  text length is more than one letter after deleting
  if (activeItem.text.length() > characterSet[activeItem.activeCharIndex].length()) {

    // trim text by its last letter
  activeItem.text = activeItem.text.substring(0, activeItem.text.length()-characterSet[activeItem.activeCharIndex].length());

    // update activeCharIndex
    for (int i = 0; i < characterSet.length; i++) {
      if ((""+characterSet[i]).equals((""+activeItem.text.charAt(activeItem.text.length()-1))) == true) {
        activeItem.activeCharIndex = i;
        break;
      }
    }

    // play sound of this function
    if (interfaceSound == true) {
      playSound("delete letter");
    }
  }
}

public void setFontStyle() {

  // only switch font style if fontFamily has more than one entry
  if (activeItem.fontFamily.length > 1) {

    // increase fontFamilyIndex by one
    activeItem.fontFamilyIndex++;

    // if fontFamilyIndex exeeds the entry amount of fontFamily, step back to zero
    if (activeItem.fontFamilyIndex >= activeItem.fontFamily.length) {
      activeItem.fontFamilyIndex = 0;
    }

    // play sound of this function
    if (interfaceSound == true) {
      playSound("switch mode");
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– CAMERA –––––––––––––––––––

// MODIFIED VARIABLES
// boolean  activeItem.camModeLive   :  live or camera shot
// PImage   activeItem.img           :  pictured image
// boolean  activeItem.defaultColor  :  image in default color or duplex color
// PImage[] activeItem.imgDuplex     :  array of duplex images for every entry in 'myColors'
// Color[]  myColors                 :  array of imported colors

public void switchCamMode_LiveOrShot() {

  activeItem.camModeLive = !activeItem.camModeLive;

  if (activeItem.camModeLive == false) {

    // set item color to default color if its the first shot, else save the previous set color
    if (activeItem.img == null) {
      activeItem.defaultColor = true;
    }

    // copy image from camera stream
    activeItem.imgDefault = activeItem.cam.copy();

    // generate duplex images for all colors
    for (int i = 0; i < myColors.length; i++) {
      activeItem.imgDuplex[i] = activeItem.createColorImage(activeItem.imgDefault, myColors[i], false);
    }

    // update the active image
    activeItem.updateImg();
  }

  // play sound of this function
  if (interfaceSound == true) {
    playSound("switch mode");
  }
}

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– IMAGE ––––––––––––––––––––

// MODIFIED VARIABLES
// boolean  activeItem.imageModeAlpha  :  alpha on or off
// boolean  activeItem.defaultColor    :  image in default color or duplex color

public void switchImageMode_AlphaOnOrOff() {

  // only change alpha mode if defaultColor is off
  if (activeItem.defaultColor == false) {

    // switch imageModeAlpha
    activeItem.imageModeAlpha = !activeItem.imageModeAlpha;

    // update the active image
    activeItem.updateImg();

    // play sound of this function
    if (interfaceSound == true) {
      playSound("switch mode");
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– VECTOR –––––––––-–––––––––

// MODIFIED VARIABLES
// Boolean  vectorModeStroke         :  stroke or fill
// Float    activeItem.strokeWeight  :  thicknesss of stroke

// EDITABLE VARIABLES
float strokeWeightDefault = 250;
float strokeWeightMin = 100;
float strokeWeightMax = 1000;
float strokeWeightIncrement = 150;

public void switchVectorMode_FillOrStroke() {

  // switch vectorModeStroke
  activeItem.vectorModeStroke = !activeItem.vectorModeStroke;

  // play sound of this function
  if (interfaceSound == true) {
    playSound("switch mode");
  }
}

public void setStrokeWeightPlus() {

  // only change strokeWeight if vectorModeStroke is active
  if (activeItem.vectorModeStroke == true) {

    // only increase strokeWeight if strokeWeight is below strokeWeightMax value
    if (activeItem.strokeWeight < strokeWeightMax) {

      // add strokeWeightIncrement to strokeWeight
      activeItem.strokeWeight = activeItem.strokeWeight + strokeWeightIncrement;

      // constrain strokeWeight to minimum and maximum values
      activeItem.strokeWeight = constrain(activeItem.strokeWeight, strokeWeightMin, strokeWeightMax);

      // play sound of this function
      if (interfaceSound == true) {
        playSound("strokeweight");
      }
    } else {

      // play sound of this function
      if (interfaceSound == true) {
        playSound("strokeweight max");
      }
    }
  }
}

public void setStrokeWeightMinus() {

  // only change strokeWeight if vectorModeStroke is active
  if (activeItem.vectorModeStroke == true) {

    // only increase strokeWeight if strokeWeight is above strokeWeightMin value
    if (activeItem.strokeWeight > strokeWeightMin) {

      // subtract strokeWeightIncrement to strokeWeight
      activeItem.strokeWeight = activeItem.strokeWeight - strokeWeightIncrement;

      // constrain strokeWeight to minimum and maximum values
      activeItem.strokeWeight = constrain(activeItem.strokeWeight, strokeWeightMin, strokeWeightMax);

      // play sound of this function
      if (interfaceSound == true) {
        playSound("strokeweight");
      }
    } else {

      // play sound of this function
      if (interfaceSound == true) {
        playSound("strokeweight max");
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– COLOR -–––––––––-–––––––––

// MODIFIED VARIABLES
// Color   activeItem.col       :  active color
// Int     activeItem.colIndex  :  index of active color in myColors
// Color   bgColor              :  background color
// Int     bgColorIndex         :  index of bgColor in myColors
// String  activeItem.type      :  type of item ( image, vector, font or cam)

// EDITABLE VARIABLES
int [] myColors = {0xFF000000, 0xFFFF0000, 0xFFFFFF00, 0xFF00FF00, 0xFF00FFFF, 0xFF0000FF, 0xFFFF00FF, 0xFFFFFFFF}; // preset if no image is found to import colors
/*
 You can use an image as source to load a range of colors to use it myColors array.
 The source image must be placed in the data folder 'data/input/colors' and is imported and analysed at setup.
 If you want to add your colors manually just delete the 'colors.png' and add you colors as HEX-code to the follwing array 'myColors'.
 */
int maxImportColors = 10; // amount of colors that are imported from source image.

public void setItemColorToNext() {

  // differing handling for image/cam types to other types
  if (activeItem.type == "image" || activeItem.type == "cam") {

    // if defaultColor is true then deactivate, else increase colIndex by one
    if (activeItem.defaultColor) {
      activeItem.defaultColor = false;
    } else {
      activeItem.colIndex++;
    }

    // if colIndex exeeds total amount of colors in myColors, then jump back to zero and set defaultColor to true
    if (activeItem.colIndex >= myColors.length) {
      activeItem.colIndex = 0;
      activeItem.defaultColor = true;
    }

    // update the active image
    activeItem.updateImg();
  } else {

    // increase colIndex by one
    activeItem.colIndex++;

    // if colIndex exeeds total amount of colors in myColors, then switch to the remainder
    activeItem.colIndex = activeItem.colIndex%myColors.length;
  }

  // update the active color to colIndex in myColors
  activeItem.col = myColors[activeItem.colIndex];

  // play sound of this function
  if (interfaceSound == true) {
    playSound("color");
  }
}

public void setItemColorToPrevious() {

  // decrease colIndex by one
  activeItem.colIndex--;

  // check if colIndex goes below zero
  if (activeItem.colIndex < 0) {

    // differing handling for image/cam types to other types
    if (activeItem.type == "image" || activeItem.type == "cam") {

      // check if defaultColor is already active
      if (!activeItem.defaultColor) {

        // else switch defaultColor on and set colIndex back to zero
        activeItem.defaultColor = true;
        activeItem.colIndex = 0;
      } else {

        // else switch defaultColor off and jump colIndex to entry amount of myColors (minus one because index count starts at 0)
        activeItem.defaultColor = false;
        activeItem.colIndex = myColors.length-1;
      }
    } else {

      // jump colIndex to entry amount of myColors (minus one because index count starts at 0)
      activeItem.colIndex = myColors.length-1;
    }
  }

  // update the active color to colIndex in myColors
  activeItem.col = myColors[activeItem.colIndex];

  // update the active image
  if (activeItem.type == "image" || activeItem.type == "cam") {
    activeItem.updateImg();
  }

  // play sound of this function
  if (interfaceSound == true) {
    playSound("color");
  }
}

public void setBackgroundColorToNext() {

  // increase bgColIndex by one
  bgColorIndex++;

  // if bgColIndex exeeds total amount of colors in myColors, then jump back to zero
  if (bgColorIndex >= myColors.length) {
    bgColorIndex = 0;
  }

  // update the bgColor to bgColIndex in myColors
  bgColor = myColors[bgColorIndex];


  // play sound of this function
  if (interfaceSound == true) {
    playSound("background color");
  }
}

public void setBackgroundColorToPrevious() {

  // decrease bgColIndex by one
  bgColorIndex--;

  // if bgColIndex goes below zero jump bgColorIndex to entry amount of myColors (minus one because index count starts at 0)
  if (bgColorIndex < 0) {
    bgColorIndex = myColors.length-1;
  }

  // update the bgColor to bgColIndex in myColors
  bgColor = myColors[bgColorIndex];


  // play sound of this function
  if (interfaceSound == true) {
    playSound("background color");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– BLEND MODE ––-––––––––––––

// MODIFIED VARIABLES
// activeItem.blendMode       :  blendMode as integer
// activeItem.blendModeIndex  :  index of blendMode in blendModes

// EDITABLE VARIABLES
int [] blendModes = {BLEND, MULTIPLY, DIFFERENCE};

public void switchBlendMode() {

  // increase blendModeIndex by one
  activeItem.blendModeIndex++;

  // if blendModeIndex exeeds total amount of blendModes, then jump back to zero
  if (activeItem.blendModeIndex >= blendModes.length) {
    activeItem.blendModeIndex = 0;
  }

  // update blendMode to blendModeIndex in blendModes
  activeItem.blendMode = blendModes[activeItem.blendModeIndex];

  // play sound of this function
  if (interfaceSound == true) {
    playSound("switch mode");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– RANDOM -––––––––-–––––––––

// MODIFIED VARIABLES
// Bool   activeItem.randomSet  :  activate to trigger setupRandom() in next loop
// Color  bgColor               :  background color
// Int    bgColorIndex          :  index of bgColor in myColors
// String  activeItem.type      :  type of item ( image, vector, font or cam)

public void setupRandom() {

  // activate randomSet for next loop
  activeItem.randomSet = true;

  // play sound of this function
  if (interfaceSound == true) {
    playSound("random");
  }
}


public void setupAllItemsRandom() {

  // get random value for bgColorIndex and update bgColor to bgColorIndex in myColors
  bgColorIndex = floor(random(myColors.length));
  bgColor = myColors[bgColorIndex];

  // activate randomSet for next loop for all items
  for (int i = 0; i < myItems.size(); i++) {
    myItems.get(i).randomSet = true;
  }

  // play sound of this function
  if (interfaceSound == true) {
    playSound("all random");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

public void randomReset(GraphicItem item) {

  // activate or deactivate which variables should be set by random
  randomResetPosition(item);
  randomResetScale(item);
  randomResetRotation(item);
  randomResetColor(item);
  randomResetBlendMode(item);

  if (item.type == "image") {
    randomResetImage(item);
  } else if (item.type == "vector") {
    randomResetVector(item);
  } else if (item.type == "font") {
    randomResetFont(item);
  } else if (item.type == "cam") {
    randomResetCam(item);
  }

  if (item.animation == true) {
    randomResetAnimation(item);
  }

  if (item.repetition == true) {
    randomResetRepetition(item);
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// PVector  item.position

// EDITABLE VARIABLES
float randomMargin = margin;
float randomHorizontalGridSize = horizontalGridSize;
float randomVerticalGridSize = verticalGridSize;

public void randomResetPosition(GraphicItem item) {

  // generate random value
  float randomX = random(randomMargin, width-randomMargin);
  float randomY = random(randomMargin, height-randomMargin);

  // grifify random value
  // randomX = round(randomX / randomHorizontalGridSize) * randomHorizontalGridSize;
  // randomY = round(randomY / randomVerticalGridSize) * randomVerticalGridSize;

  // set position to random value
  item.position.x = randomX;
  item.position.y = randomY;
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// Float  item.scale

// EDITABLE VARIABLES
float randomScaleMin = scaleMin;
float randomScaleMax = scaleMax;
float randomScaleGridSize = scaleGridSize;

public void randomResetScale(GraphicItem item) {

  // generate random values for scale
  float randomScale = random(randomScaleMin, randomScaleMax);
  // float randomScale = item.scale * random(0.8, 1.2);

  // grifify random value
  // randomScale = round(randomScale / randomScaleGridSize) * randomScaleGridSize;

  // set scale to random value
  item.scale = randomScale;
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// Float  item.rotation

// EDITABLE VARIABLES
float randomRotationMin = 0;
float randomRotationMax = 360;
float randomRotationGridSize = rotationGridSize;

public void randomResetRotation(GraphicItem item) {

  // generate random value
  float randomRotation = random(randomRotationMin, randomRotationMax);

  //rotate by either positive or negative rotationGridSize
  //float randomDirection = 0;
  //if (boolean(floor(random(2))) == true) {
  //  randomDirection = 1;
  //}  else {
  //  randomDirection = -1
  //}
  //float randomRotation = item.rotation + randomRotationGridSize * randomDirection;

  // grifify random value
  // randomRotation = round(randomRotation / randomRotationGridSize) * randomRotationGridSize;

  // set rotation to random value
  item.rotation = randomRotation;
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// Color     item.col       :  active color
// Int       item.colIndex  :  index of active color in myColors
// Color []  myColors       :  set of colors imported at setup

public void randomResetColor(GraphicItem item) {

  // generate random colIndex value
  item.colIndex = floor(random(myColors.length));

  // update color to colIndex in myColors
  item.col = myColors[item.colIndex];
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// Int []  blendModes   :  set of blendModes
// item.blendMode       :  blendMode as integer
// item.blendModeIndex  :  index of blendMode in blendModes

public void randomResetBlendMode(GraphicItem item) {

  // generate random index value
  int randomIndex = floor(random(blendModes.length));

  // update blendModeIndex and set blend mode to randomIndex in blendModes
  item.blendModeIndex = randomIndex;
  item.blendMode = blendModes[item.blendModeIndex];
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// boolean  item.imageModeAlpha  :  alpha on or off
// boolean  item.defaultColor    :  image in default color or duplex color

public void randomResetImage(GraphicItem item) {

  // generate random toggle (chance 1 : myColors entries)
  boolean randomToggle = PApplet.parseBoolean(floor(random(myColors.length)));

  // randomToggle value sets if item is in defaultColor
  if (randomToggle == true) {
    item.defaultColor = true;
  } else {
    item.defaultColor = false;

    // random toggle if duplex image has alpha
    item.imageModeAlpha = PApplet.parseBoolean(floor(random(2)));
  }

  // update the active image
  item.updateImg();
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// Boolean  vectorModeStroke   :  stroke or fill
// Float    item.strokeWeight  :  thicknesss of stroke

// EDITABLE VARIABLES
float randomStrokeWeightMin = strokeWeightMin;
float randomStrokeWeightMax = strokeWeightMax;
float randomStrokeWeightIncrement = strokeWeightIncrement;

public void randomResetVector(GraphicItem item) {

  // random toggle if vector mode is stroke (or fill)
  item.vectorModeStroke = PApplet.parseBoolean(floor(random(2)));

  // generate random value
  if (item.vectorModeStroke == true) {
    float randomStrokeWeight = random(randomStrokeWeightMin, randomStrokeWeightMax);

    //increment/decrement by randomStrokeWeightIncrement
    //float randomDirection = 0;
    //if (boolean(floor(random(2))) == true) {
    //  randomDirection = 1;
    //}  else {
    //  randomDirection = -1
    //}
    //float randomStrokeWeight = item.strokeWeight + randomStrokeWeightIncrement * randomDirection;

    // set strokeWeight to random value
    item.strokeWeight = randomStrokeWeight;
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// Int  item.fontFamilyIndex  :  index of fontstyle in fontFamily

public void randomResetFont(GraphicItem item) {

  // generate random fontFamilyIndex value
  item.fontFamilyIndex = floor(random(item.fontFamily.length));
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// boolean  item.camModeLive   :  live or camera shot
// boolean  item.defaultColor  :  image in default color or duplex color
// PImage[] item.imgDuplex     :  array of duplex images for every entry in 'myColors'
// Color[]  myColors           :  array of imported colors

public void randomResetCam(GraphicItem item) {

  // random toggle if camModeLive is live or shot
  item.camModeLive = PApplet.parseBoolean(floor(random(2)));

  // if camModeLive is false then update the current image as
  if (item.camModeLive == false) {

    // generate random toggle (chance 1 : myColors entries)
    boolean randomToggle = PApplet.parseBoolean(floor(random(myColors.length)));

    // randomToggle value sets if item is in defaultColor or duplex
    if (randomToggle == true) {
      item.defaultColor = true;
    } else {
      item.defaultColor = false;
    }

    // copy image from camera stream
    item.imgDefault = item.cam.copy();

    // generate duplex images for all colors
    for (int i = 0; i < myColors.length; i++) {
      item.imgDuplex[i] = item.createColorImage(item.imgDefault, myColors[i], false);
    }

    // update the active image
    item.updateImg();
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––


// MODIFIED VARIABLES
// Float  item.animationTransPos  :  transfer position (animating between item.position and item.animationTransPos)
// Float  item.animationTransRot  :  transfer rotation (animating between item.rotation and item.animationTransRot)
// Float  item.animationTransSca  :  transfer scale (animating between item.scale and item.animationTransSca)

// EDITABLE VARIABLES
float randomMaxDecrement = 0.8f;
float randomMaxIncrement = 1.2f;

public void randomResetAnimation(GraphicItem item) {

  // multiply animation values by random
  item.animationTransXPos = item.animationTransXPos * random(randomMaxDecrement, randomMaxIncrement);
  item.animationTransYPos = item.animationTransYPos * random(randomMaxDecrement, randomMaxIncrement);
  item.animationTransRot =  item.animationTransRot * random(randomMaxDecrement, randomMaxIncrement);
  item.animationTransSca =  item.animationTransSca * random(randomMaxDecrement, randomMaxIncrement);
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––

// MODIFIED VARIABLES
// PVector  item.repetitionDirection  :  transfer direction (sets distance between repetitions)
// PVector  item.repetitions          :  count of x/y repetitions

// EDITABLE VARIABLES
float randomMaxNegativeShift;
float randomMaxPositiveShift;
float randomMaxRepetitions = 5;

public void randomResetRepetition(GraphicItem item) {

  randomMaxNegativeShift = item.size * 0.5f;
  randomMaxPositiveShift = item.size * 2;

  // generate random values
  float randomXDirection = floor(random(randomMaxNegativeShift, randomMaxPositiveShift));
  float randomYDirection = floor(random(randomMaxNegativeShift, randomMaxPositiveShift));
  float randomXRepetitions = floor(random(1, randomMaxRepetitions));
  float randomYRepetitions = floor(random(1, randomMaxRepetitions));

  // grifify random value
  // randomXDirection = round(randomXDirection / horizontalGridSize) * horizontalGridSize;
  // randomYDirection = round(randomYDirection / verticalGridSize) * verticalGridSize;

  // set repetitionDirection and repetitions to random value
  item.repetitionDirection.set(randomXDirection, randomYDirection);
  item.repetitions.set(randomXRepetitions, randomYRepetitions);
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVE –––––––––––––––

// Check the previously pressed button combo for a match.
// For a valid combo it returns the specific power move or nothing if invalid.
public String checkCombo(String combo) {
  switch(combo) {
  case "SquareCrossCircle":
  case "1QA":
    comboValid = true;
    return "drawing";
  case "TriangleCircleCross":
  case "4R5":
    comboValid = true;
    return "animation";
  case "CircleSquareUp":
  case "7UK":
    comboValid = true;
    return "repetition";
  case "NewButtonCombo":      // Gamepad Combo
  case "NBC":                 // Keyboard Combo (3 keys)
    comboValid = true;
    return "new power move";  // power move name for functions below
  default:
    comboValid = false;
    return "";
  }
}


// Trigger the power move function depending on which power move is activated.
public void updatePowerMove() {
  switch(powerMove) {
  case "drawing":
    drawWithItem();
    break;
  case "animation":
    animateItem();
    break;
  case "repetition":
    repeatItem();
    break;
  case "new power move":
    // add function here
    break;
  }
}


// Delete the settings depending on which power move is activated.
public void deletePowerMove() {
  switch(powerMove) {
  case "drawing":
    deleteItemDrawing();
    break;
  case "animation":
    deleteItemAnimation();
    break;
  case "repetition":
    deleteItemRepetition();
    break;
  case "new power move":
    // add function here
    break;
  }
  quitPowerMoveMode();

  // play sound of this function
  if (interfaceSound == true) {
    playSound("delete power move");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVE: DRAWING ––––––

public void drawWithItem() {

  // update item drawing with current settings
  activeItem.updateDrawing();

  // play sound of this function
  if (powerMoveMode) {
  }
}

public void deleteItemDrawing() {

  // activate drawingDelete function for next loop
  activeItem.drawingDelete = true;

  // play sound of this function
  if (interfaceSound == true) {
    playSound("delete drawing");
  }
}

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVE: REPETITION –––


// MODIFIED VARIABLES
// PVector  item.repetitionDirection  :  transfer direction (sets distance between repetitions)
// PVector  item.repetitions          :  count of x/y repetitions

// EDITABLE VARIABLES
int maxRepetitions = 5;

public void repeatItem() {

  // update item repetition settings
  activeItem.updateRepetition();
}

public void deleteItemRepetition() {

  // deactivate repetition
  activeItem.repetition = false;

  // play sound of this function
  if (interfaceSound == true) {
    playSound("delete repetition");
  }
}

public void setXRepetitionPlus() {

  // only increase repetition if current value is below maxValue
  if (activeItem.repetitions.x < maxRepetitions) {

    // increment value by one
    activeItem.repetitions.set(activeItem.repetitions.x+1, activeItem.repetitions.y);

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition");
    }
  } else {

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition max");
    }
  }
}

public void setXRepetitionMinus() {

  // only decrease repetition if current value is above one
  if (activeItem.repetitions.x > 1) {

    // decrement value by one
    activeItem.repetitions.set(activeItem.repetitions.x-1, activeItem.repetitions.y);

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition");
    }
  } else {

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition max");
    }
  }
}

public void setYRepetitionPlus() {

  // only increase repetition if current value is below maxValue
  if (activeItem.repetitions.y < maxRepetitions) {

    // increment value by one
    activeItem.repetitions.set(activeItem.repetitions.x, activeItem.repetitions.y+1);

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition");
    }
  } else {

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition max");
    }
  }
}

public void setYRepetitionMinus() {

  // only decrease repetition if current value is above one
  if (activeItem.repetitions.y > 1) {

    // decrement value by one
    activeItem.repetitions.set(activeItem.repetitions.x, activeItem.repetitions.y-1);

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition");
    }
  } else {

    // play sound of this function
    if (interfaceSound == true) {
      playSound("repetition max");
    }
  }
}

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– POWER MOVE: ANIMATION -–––

// MODIFIED VARIABLES
// Float  item.animationPos  :  current position (animating between item.position and item.animationTransPos)
// Float  item.animationRot  :  current rotation (animating between item.rotation and item.animationTransRot)
// Float  item.animationSca  :  current scale (animating between item.scale and item.animationTransSca)
// Float  item.animationTransPos  :  transfer position
// Float  item.animationTransRot  :  transfer rotation
// Float  item.animationTransSca  :  transfer scale

// EDITABLE VARIABLES
float animationSpeedDefault = 30; //fps
float animationSpeedMax = 7.5f;
float animationSpeedMin = 120;
float animationSpeedIncrement = 2.0f;
float animationNoise = 0;

public void animateItem() {

  // update item animation settings
  activeItem.updateAnimation();
}


public float[] updateAnimationValues(GraphicItem item) {

  // update values based on speed and animation settings

  // sine animation (wavy)
  float animationXPos = sin(frameCount / item.animationSpeed)*(item.animationTransXPos);
  float animationYPos = sin(frameCount / item.animationSpeed)*(item.animationTransYPos);
  float animationRot = sin(frameCount / item.animationSpeed)*(item.animationTransRot);
  float animationSca = sin(frameCount / item.animationSpeed)*(item.animationTransSca);

  // circular animation (wavy)
  //float animationXPos = cos(frameCount / item.animationSpeed)*(item.animationTransXPos);
  //float animationYPos = sin(frameCount / item.animationSpeed)*(item.animationTransYPos);

  // loop circular
  //float animationXPos = map(frameCount%item.animationSpeed, 0, item.animationSpeed, 0, item.animationTransXPos);
  //float animationYPos = map(frameCount%item.animationSpeed, 0, item.animationSpeed, 0, item.animationTransYPos);
  //float animationRot = map(frameCount%item.animationSpeed, 0, item.animationSpeed, 0, item.animationTransRot);
  //float animationSca = map(frameCount%item.animationSpeed, 0, item.animationSpeed, 0, item.animationTransSca)

  // noise
  //float animationXPos = map(noise(animationNoise), 0, 1, 0, item.animationTransXPos);
  //float animationYPos = map(noise(animationNoise), 0, 1, 0, item.animationTransYPos);
  //float animationRot = map(noise(animationNoise), 0, 1, 0, item.animationTransRot);
  //float animationSca = map(noise(animationNoise), 0, 1, 0, item.animationTransSca);
  //animationNoise = animationNoise + 1/item.animationSpeed;

  // return updated values to animate item
  float [] updatedValues = {animationXPos, animationYPos, animationRot, animationSca};
  return updatedValues;
}


public void setAnimationSpeedPlus() {

  // only increase speed if value would be below animationSpeedMin
  if (activeItem.animationSpeed / animationSpeedIncrement >= animationSpeedMax) {

    //multiply animationSpeed by animationSpeedIncrement
    activeItem.animationSpeed = activeItem.animationSpeed / animationSpeedIncrement;

    // play sound of this function
    if (interfaceSound == true) {
      playSound("set animation speed");
    }
  } else {

    // play sound of this function
    if (interfaceSound == true) {
      playSound("set animation speed max");
    }
  }
}

public void setAnimationSpeedMinus() {

  // only decrease speed if value would be above animationSpeedMax
  if (activeItem.animationSpeed * animationSpeedIncrement <= animationSpeedMin) {

    //divide animationSpeed by animationSpeedIncrement
    activeItem.animationSpeed = activeItem.animationSpeed * animationSpeedIncrement;

    // play sound of this function
    if (interfaceSound == true) {
      playSound("set animation speed");
    }
  } else {

    // play sound of this function
    if (interfaceSound == true) {
      playSound("set animation speed max");
    }
  }
}

public void deleteItemAnimation() {

  // delete and reset animation values
  activeItem.resetAnimation();

  // play sound of this function
  if (interfaceSound == true) {
    playSound("delete animation");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– FUNCTIONALITY VARIABLES -–––

// !!! NO CHANGES HERE !!!
float xInputDirection = 0, yInputDirection = 0;
float sInputDirection = 0;
float rInputDirection = 0;
float gridSpeed = 8;
// !!! NO CHANGES HERE !!!
public void displayJoystickState() {

    miniControlSwitchTimer();

    //make createRandomJoystickDrift run for 10 seconds then invertMoveControls for 10 seconds then invertSensibility for 10 seconds then loop back to createRandomJoystickDrift
    float millisForFunction = millis() % 20000;
    if (millisForFunction < 10000) {
        createRandomJoystickDrift();
    } else if (millisForFunction < 20000) {
        invertMoveControls();
    }
    //else if (millisForFunction < 30000) {
    //     invertSensibility();
    // }
    

    circle(100 + LX * 10,100 + LY * 10,10);
    pushStyle();
        noFill();
        strokeWeight(2);
        stroke(0);
        circle(100, 100, 35);
    
    textFont(UIFontSmall);
    textAlign(LEFT, TOP);
    text("LX: " + String.format("%.3f", LX), 10, 150);
    text("LY: " + String.format("%.3f", LY), 10, 200);
    popStyle();
}

public void createRandomJoystickDrift() {
    // use noise instead of random
    // * 1 is the intensity of the drift
    // * 0.000X is the speed of the drift changes
    LX += (noise(millis() * 0.0004f) - 0.5f) * 1;
    LY += (noise(millis() * 0.0008f) - 0.5f) * 1;

    //constrain 
    LX = constrain(LX, -1, 1);
    LY = constrain(LY, -1, 1);
}

public void invertMoveControls() {
    float temp = LX;
    LX = -LY;
    LY = temp;
}

public void miniControlSwitchTimer() {
    //every 10 seconds mini stopwatch does 1 rotation 
    float millisForFunction = millis() % 10000;
    float angle = map(millisForFunction, 0, 10000, 0, 360);
    push();
        translate(width-100, height-100);
        scale(0.25f);
        rotate(radians(angle));
        strokeWeight(5);
        stroke(0);
        line(0, 0, 0, -50);
        noFill();
        circle(0, 0, 100);
    pop();
}

// void invertSensibility() {
//     if (LX < -0.05) {
//         LX = map(LX, -1, -0.05, -0.05, -1);
//     } else if (LX > 0.05) {
//         LX = map(LX, 0.05, 1, 1, 0.05);
//     }

//     if (LY < -0.05) {
//         LY = map(LY, -1, -0.05, -0.05, -1);
//     } else if (LY > 0.05) {
//         LY = map(LY, 0.05, 1, 1, 0.05);
//     }
// }

public void invertSensibility() {
    if (LX < -0.05f) {
        LX = map(LX, -1, -0.05f, -0.05f, -1);
    } else if (LX > 0.05f) {
        LX = map(LX, 0.05f, 1, 1, 0.05f);
    }

    if (LY < -0.05f) {
        LY = map(LY, -1, -0.05f, -0.05f, -1);
    } else if (LY > 0.05f) {
        LY = map(LY, 0.05f, 1, 1, 0.05f);
    }
}

// !!! PLEASE DO NOT MODIFY THIS TAB !!! ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––– !!! PLEASE DO NOT MODIFY THIS TAB !!! 

/*
 The 'Power Move Mode' is a special program mode featuring a set of additional effects.
 This tab stores only the program functionaly of this mode.
 To add a new move watch for the functions 'checkCombo', 'updatePowerMove' and 'deleteCombo' in the 'GraphicItemControlFunctions' tab.
 */


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– FICED VARIABLES –––––––––––––

// Mode
boolean powerMoveMode = false;

// Button Combo
Boolean  comboMode = false;
int      comboModeTimerAtStart;
int      comboModeTimerMax = 2; //SECONDS
String[] combo = {"", "", ""};
int      comboIndex = 0;
String   comboKeys = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";

Boolean  comboComplete = false;
Boolean  comboValid = false;
int      comboCompleteTimerAtStart;
int      comboCompleteTimerMax = 1;
float    transition = 0.9f;

//Move
Boolean  moveMode = false;
String   powerMove = "";


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– UPDATE -––––––––––––––––––––

public void updatePowerMoveMode() {
  if (comboMode) {
    updateComboMode();
  } else if (moveMode) {
    updatePowerMove();
  }
}

public void updateComboMode() {
  // Check if timer is over and if the combo is complete to check for validation and combo move
  int comboTimer = ceil(map(frameCount-comboModeTimerAtStart, 0, comboModeTimerMax*frameRate, comboModeTimerMax, 0));
  if (comboTimer < 0) {
    quitPowerMoveMode();
  } else if (comboComplete) {
    if (frameCount > comboCompleteTimerAtStart + (comboCompleteTimerMax*frameRate)) {
      if (comboValid == true) {
        comboMode = false;
      } else {
        quitPowerMoveMode();
      }
    }
  } else if (comboIndex == 3) {
    comboComplete = true;
    comboCompleteTimerAtStart = frameCount;
    comboModeTimerAtStart += comboCompleteTimerMax*frameRate;
    String comboString = "" + combo[0] + combo[1] + combo[2];
    powerMove = checkCombo(comboString);
    if (comboValid) {
      moveMode = true;
      if (interfaceSound == true) {
        playSound("valid combo");
      }
    } else {
      if (interfaceSound == true) {
        playSound("invalid combo");
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DISPLAY –––––––––-––––––––––

public void  displayPowerMoveMode() {
  if (comboMode) {
    displayComboMode();
  }
  if (moveMode) {
    displayMoveMode();
  }
}

public void displayComboMode() {

  float animationOut = 0;
  if (comboComplete == false) {
    animationOut = 1.0f;
  } else {
    animationOut = map(frameCount, comboCompleteTimerAtStart + comboCompleteTimerMax*transition*frameRate,
      comboCompleteTimerAtStart + comboCompleteTimerMax*frameRate, 1.0f, 0);
    animationOut = constrain(animationOut, 0.0f, 1.0f);
  }

  float animationIn = constrain(map(frameCount-comboModeTimerAtStart, 0, comboModeTimerMax*frameRate, 0, TWO_PI), 0, TWO_PI);
  float size = min(width, height) / 2;

  pushStyle();
  pushMatrix();

  blendMode(BLEND);
  strokeCap(SQUARE);

  translate(width/2, height/2);
  noStroke();
  fill(grey, (255*(1.0f-alphaInactivityMin))*animationOut);
  rect(0, 0, width, height);

  if (comboComplete) {
    noFill();
    if (comboValid == true) {
      stroke(black, animationOut*255);
    } else {
      stroke(red, animationOut*255);
    }
    strokeWeight(UIstrokeWeight);
    ellipse(0, 0, size, size);
  } else {

    noFill();
    stroke(white, animationOut*255);
    strokeWeight(UIstrokeWeight);
    ellipse(0, 0, size, size);
    stroke(black);
    arc(0, 0, size, size, 0-HALF_PI, animationIn-HALF_PI, OPEN);
  }

  if (comboValid == true) {
    translate(0, UItextSize*0.25f);
    fill(black, animationOut*255);
    textFont(UIFontBold);
    textSize(UItextSize);
    textAlign(CENTER);
    text("" + powerMove, 0, 0);
    textFont(UIFontRegular);
    textSize(UItextSize*0.5f);
    textAlign(CENTER);
    text("active", 0, UItextSize*0.75f);
  } else {
    noStroke();
    translate(-(UIstrokeWeight*3), 0);
    for ( int i = 0; i<3; i++) {
      if (comboComplete) {
        fill(red, animationOut*255);
      } else if (i+1 > comboIndex) {
        fill(white, animationOut*255);
      } else {
        fill(black, animationOut*255);
      }
      ellipse(0, 0, UIstrokeWeight*1.4f, UIstrokeWeight*1.4f);
      translate(UIstrokeWeight*3, 0);
    }
  }

  popMatrix();
  popStyle();
}

public void displayMoveMode() {
  float animationIn = map(frameCount, comboCompleteTimerAtStart + comboCompleteTimerMax*transition*frameRate, 
  comboCompleteTimerAtStart + comboCompleteTimerMax*frameRate, 0.0f, 1.0f);
  animationIn = constrain(animationIn, 0.0f, 1.0f);
  pushStyle();
  pushMatrix();
  blendMode(BLEND);
  strokeWeight(UIstrokeWeight*2*animationIn);
  noFill();
  stroke(white);
  rect(width/2, height/2, width, height);
  popMatrix();
  popStyle();
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ACTIVATE –––––––––––––––––––

public void activatePowerMoveMode() {
  powerMoveMode = true;
  comboMode = true;
  moveMode = false;
  comboModeTimerAtStart = frameCount;
  comboCompleteTimerAtStart = 0;
  comboComplete = false;
  comboValid = false;
  if (interfaceSound == true) {
    playSound("activate power move");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– QUIT –––––––––––––––––––––––

public void quitPowerMoveMode() {
  powerMoveMode = false;
  comboMode = false;
  moveMode = false;
  comboIndex = 0;
  combo[0] = "";
  combo[1] = "";
  combo[2] = "";
  powerMove = "";
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– CONFIRM ––––––––––––––––––––

public void confirmPowerMove() {
  quitPowerMoveMode();
  if (interfaceSound == true) {
    playSound("confirm power move");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– RESET ––––––––––––––––––––––

public void resetPowerMove() {
  deletePowerMove();
  if (interfaceSound == true) {
    playSound("reset power move");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––---–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ADD BUTTON –––––––––––––––––

public void addButtonToCombo(String s) {
  combo[comboIndex] = s;
  comboIndex++;
  if (interfaceSound == true) {
    playSound("add combo");
  }
}

// !!! PLEASE DO NOT MODIFY THIS TAB !!! ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––– !!! PLEASE DO NOT MODIFY THIS TAB !!! 

/*
 This tab stores all the essential functions related to the program functionality.
 */


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– FIXED VARIABLES ––––––––––

// masterFiles: Storage of all imported files from tha data folder. They work as master template for the displayed items.
// Files that can be imported are: jpeg, png, otf, and svg
ArrayList<GraphicItem> masterFiles = new ArrayList<GraphicItem>();

// activeMasterFileIndex: links the master template to the activeItem
int activeMasterFileIndex = 0;

// myItems: all displayed items with individual settings
ArrayList<GraphicItem> myItems = new ArrayList<GraphicItem>();

// activeMyItemsIndex links the myItems entry to the activeItem
int activeMyItemsIndex = -1;

// The current active item that is changable
GraphicItem activeItem;

// Colors
int white = color(255);
int black = color(0);
int grey = color(220);
int red = color(255, 0, 0);
int bgColor;
int bgColorIndex;

// Interface
float UItextSize;
float UIstrokeWeight;
PFont UIFontRegular;
PFont UIFontBold;
PFont UIFontSmall;


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ADD ITEM –––––––––––––––––

public void addItem() {

  if (activeMyItemsIndex != myItems.size()-1) {
    myItems.add(myItems.get(myItems.size()-1));
    for (int i = myItems.size()-2; i > activeMyItemsIndex+1; i--) {
      myItems.set(i, myItems.get(i-1));
    }

    String activeType = masterFiles.get(activeMasterFileIndex).type;
    switch(activeType) {
    case "font":
      myItems.set(activeMyItemsIndex+1, new fontItem (masterFiles.get(activeMasterFileIndex)));
      break;
    case "image":
      myItems.set(activeMyItemsIndex+1, new imgItem (masterFiles.get(activeMasterFileIndex)));
      break;
    case "vector":
      myItems.set(activeMyItemsIndex+1, new vectorItem (masterFiles.get(activeMasterFileIndex)));
      break;
    case "cam":
      myItems.set(activeMyItemsIndex+1, new camItem(masterFiles.get(activeMasterFileIndex)));
      break;
    }
  } else {

    String activeType = masterFiles.get(activeMasterFileIndex).type;
    switch(activeType) {
    case "font":
      myItems.add(new fontItem (masterFiles.get(activeMasterFileIndex)));
      break;
    case "image":
      myItems.add(new imgItem (masterFiles.get(activeMasterFileIndex)));
      break;
    case "vector":
      myItems.add(new vectorItem (masterFiles.get(activeMasterFileIndex)));
      break;
    case "cam":
      myItems.add(new camItem(masterFiles.get(activeMasterFileIndex)));
      break;
    }
  }

  activeMyItemsIndex++;
  if (activeItem != null) {
    myItems.get(activeMyItemsIndex).copyValues(activeItem);
    activeItem.active = false;
  }
  activeItem = myItems.get(activeMyItemsIndex);
  activeItem.active = true;
  lastActivity = frameCount;

  if (interfaceSound == true) {
    playSound("add");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DELETE ITEM –––––––––––––––


public void deleteItem() {
  if ( myItems.size() > 1) {
    myItems.remove(activeMyItemsIndex);
    if (activeMyItemsIndex >= myItems.size()) activeMyItemsIndex--;
    activeItem = myItems.get(activeMyItemsIndex);
    activeItem.active = true;
    activeMasterFileIndex = activeItem.fileIndex;
    lastActivity = frameCount;
    if (interfaceSound == true) {
      playSound("delete");
    }
  }
}

// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SWITCH FILE –––––––––––––––


public void switchGraphicFileToPrevious() {
  activeMasterFileIndex--;
  if (activeMasterFileIndex < 0) activeMasterFileIndex = masterFiles.size()-1;
  switchGraphicFile();
}

public void switchGraphicFileToNext() {
  activeMasterFileIndex++;
  activeMasterFileIndex = activeMasterFileIndex%masterFiles.size();
  switchGraphicFile();
}

public void switchGraphicFile() {
  String activeType = masterFiles.get(activeMasterFileIndex).type;
  switch(activeType) {
  case "font":
    myItems.set(activeMyItemsIndex, new fontItem (masterFiles.get(activeMasterFileIndex)));
    break;
  case "image":
    myItems.set(activeMyItemsIndex, new imgItem (masterFiles.get(activeMasterFileIndex)));
    break;
  case "vector":
    myItems.set(activeMyItemsIndex, new vectorItem (masterFiles.get(activeMasterFileIndex)));
    break;
  case "cam":
    myItems.set(activeMyItemsIndex, new camItem (masterFiles.get(activeMasterFileIndex)));
    break;
  }
  myItems.get(activeMyItemsIndex).copyValues(activeItem);
  activeItem.active = false;
  activeItem = myItems.get(activeMyItemsIndex);
  activeItem.active = true;
  if (interfaceSound == true) {
    playSound("switch file");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SET ACTIVE ITEM –––––––––––

public void setPreviousAsActive() {
  if (activeMyItemsIndex > 0) {
    activeMyItemsIndex--;
  } else {
    activeMyItemsIndex = myItems.size()-1;
  }
  switchActive();
}

public void setNextAsActive() {
  if (activeMyItemsIndex < myItems.size()-1) {
    activeMyItemsIndex++;
  } else {
    activeMyItemsIndex = 0;
  }
  switchActive();
}

public void switchActive() {
  activeItem.active = false;
  activeItem = myItems.get(activeMyItemsIndex);
  activeItem.active = true;
  activeMasterFileIndex = activeItem.fileIndex;
  if (interfaceSound == true) {
    playSound("switch active");
  }
  lastActivity = frameCount;
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– REORDER ACTIVE ITEM –––––––

public void reorderItemBackward() {
  int backwardIndex = activeMyItemsIndex - 1;
  reorder(backwardIndex);
}

public void reorderItemForward() {
  int forwardIndex = activeMyItemsIndex + 1;
  reorder(forwardIndex);
}

public void reorder(int indexToBe) {
  int indexWas = activeMyItemsIndex;
  if (indexToBe >= 0 && indexToBe < myItems.size()) {
    GraphicItem switchItem = myItems.get(indexToBe);
    myItems.set(indexToBe, activeItem);
    myItems.set(activeMyItemsIndex, switchItem);
    activeMyItemsIndex = indexToBe;
    activeItem.active = false;
    activeItem = myItems.get(activeMyItemsIndex);
    activeItem.active = true;
    lastActivity = frameCount;
    if (interfaceSound == true) {
      playSound("reorder");
    }
  } else if (interfaceSound == true) {
      playSound("reorder max");
    }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– EXPORT ––––––––––––––––––––

public void export() {
  if (interfaceSound == true) {
    playSound("export start");
  }
  exportInterface();
  PGraphics exportCanvas = createGraphics(PApplet.parseInt(width*2), PApplet.parseInt(height*2));
  float upscaleFactor = PApplet.parseFloat(exportCanvas.width) / PApplet.parseFloat(width);
  exportCanvas.beginDraw();
  exportCanvas.background(bgColor);
  for (int i = 0; i < myItems.size(); i++) {
    myItems.get(i).printCanvas(exportCanvas, upscaleFactor);
  }
  exportCanvas.endDraw();
  exportCanvas.save("export/myLayout_" + timestamp() + ".png");

  loop();
  if (interfaceSound == true) {
    playSound("export finish");
  }
}

public void exportInterface() {
  float size = min(width, height) / 3.5f;

  pushStyle();
  pushMatrix();

  blendMode(BLEND);

  translate(width/2, height/2);
  noStroke();
  fill(grey, (255*(1.0f-alphaInactivityMin)));
  rect(0, 0, width, height);

  noFill();
  stroke(black);
  strokeWeight(UIstrokeWeight/2.5f);
  ellipse(0, 0, size, size);

  translate(0, UItextSize*0.25f);
  fill(black);
  textFont(UIFontBold);
  textSize(UItextSize);
  textAlign(CENTER);
  text("export", 0, 0);

  popMatrix();
  popStyle();

  noLoop();
}

public String timestamp() {
  // get a unique timestamp of the current time (for data export)
  Calendar now = Calendar.getInstance();
  return String.format("%1$ty%1$tm%1$td_%1$tH%1$tM%1$tS", now);
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– RESET –––––––––––––––––––––

public void reset() {
  bgColorIndex = myColors.length-1;
  bgColor = myColors[bgColorIndex];
  myItems.clear();
  activeItem = null;
  activeMasterFileIndex = 0;
  activeMyItemsIndex = -1;
  addItem();
  resetPowerMove();
  if (interfaceSound == true) {
    playSound("reset");
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– LOAD FILES ––––––––––––––––

// File Observer
File folder;
File [] files;

public void loadFiles() {


  // Check for color palette
  File colorFolder = new File(dataPath("input/colors/"));
  File [] colorFiles = colorFolder.listFiles();
  if (colorFiles != null) {
    for (int i = 0; i<colorFiles.length; i++) {
      File tempFile = colorFiles[i];
      if (match(""+tempFile, ".png") != null || match(""+tempFile, ".jpeg") != null || match(""+tempFile, ".jpg") != null) {
        PImage newColors = loadImage(""+tempFile);
        newColors.loadPixels();
        int[] tempColors = newColors.pixels;
        tempColors = sort(tempColors);
        if (newColors.pixels.length < maxImportColors) {
          myColors = newColors.pixels;
        } else {
          myColors = new int[maxImportColors];
          for (int p = 0; p<maxImportColors; p++) {
            int tempIndex = (newColors.pixels.length/maxImportColors)*p;
            myColors[p] = tempColors[tempIndex];
          }
        }
        break;
      }
    }
  }
  bgColorIndex = myColors.length-1;
  bgColor = myColors[bgColorIndex];


  // list all files in data folder
  files = folder.listFiles();

  // Sort files alphabetically
  String [] filesSorted = new String [0];
  for (int i = 0; i<files.length; i++) {
    File tempFile = files[i];
    if (match(""+tempFile, ".jpg") != null || match(""+tempFile, ".jpeg") != null || match(""+tempFile, ".png") != null ||
      match(""+tempFile, ".svg") != null || match(""+tempFile, ".otf") != null) {
      filesSorted = append(filesSorted, ""+tempFile);
    }
  }
  filesSorted = sort(filesSorted);

  // Load files depending on data type
  for (int i = 0; i<filesSorted.length; i++) {
    File tempFile = new File(dataPath("" + filesSorted[i]));
    if (match(""+tempFile, ".jpg") != null)        masterFiles.add(new imgItem ("image", tempFile, i));
    else if (match(""+tempFile, ".jpeg") != null)   masterFiles.add(new imgItem ("image", tempFile, i));
    else if (match(""+tempFile, ".png") != null)   masterFiles.add(new imgItem ("image", tempFile, i));
    else if (match(""+tempFile, ".svg") != null)   masterFiles.add(new vectorItem ("vector", tempFile, i));
    else if (match(""+tempFile, ".otf") != null)   masterFiles.add(new fontItem ("font", tempFile, i));
  }

  // Add camera item
  masterFiles.add(new camItem(this));
}

public void checkFiles() {
  if (files.length != folder.listFiles().length) {
    files = folder.listFiles();

    for (int i = 0; i<files.length; i++) {
      File tempFile = files[i];
      boolean newFile = true;
      for (int j = 0; j<masterFiles.size(); j++) {
        if ((""+tempFile).equals((""+masterFiles.get(j).file))) {
          newFile = false;
        }
      }

      if (newFile) {
        if (match(""+tempFile, "colors.png") != null)  continue;
        else if (match(""+tempFile, ".jpg") != null)   masterFiles.add(new imgItem ("image", tempFile, i));
        else if (match(""+tempFile, ".png") != null)   masterFiles.add(new imgItem ("image", tempFile, i));
        else if (match(""+tempFile, ".svg") != null)   masterFiles.add(new vectorItem ("vector", tempFile, i));
        else if (match(""+tempFile, ".otf") != null)   masterFiles.add(new fontItem ("font", tempFile, i));
      }
    }
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SWITCH SOUND ––––––––––––––

public void switchInterfaceSound() {
  interfaceSound = !interfaceSound;
}

public void switchBackgroundSound() {
  backgroundSound = !backgroundSound;

  if (backgroundSound == true) {
    playBackgroundSound();
  } else {
    stopBackgroundSound();
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ACTIVITY ––––––––––––––––––

// Activity Status
int lastActivity = 0;
int activityAlphaResetStart = 60;
int activityAlphaResetLerp = 15;
float alphaInactivityMin = 0.3f;
float alphaInactivityMax = 1.0f;
float alphaInactivity = 1.0f;


public void setActivityAlpha() {
  if (frameCount-lastActivity <= activityAlphaResetStart) {
    alphaInactivity = alphaInactivityMin;
  } else if (frameCount-lastActivity > activityAlphaResetStart &&
    frameCount-lastActivity <= activityAlphaResetStart + activityAlphaResetLerp) {
    alphaInactivity = map(frameCount-lastActivity, activityAlphaResetStart,
      activityAlphaResetStart + activityAlphaResetLerp, alphaInactivityMin, alphaInactivityMax);
  } else {
    alphaInactivity = alphaInactivityMax;
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SETUP INTERFACE –––––––––––

public void setupInterface() {
  // Load and setup interface variables
  UItextSize = min(width, height) / 15;
  UIstrokeWeight = min(width, height) / 30;
  UIFontRegular = createFont("interface/font/strokeWeight-100.otf", UItextSize);
  UIFontBold = createFont("interface/font/strokeWeight-180.otf", UItextSize);
  UIFontSmall = createFont("interface/font/strokeWeight-100.otf", UItextSize*0.25f);
}


// !!! PLEASE DO NOT MODIFY THIS TAB !!! ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––– !!! PLEASE DO NOT MODIFY THIS TAB !!!

/*
 This tab imports and manages the sound elements within the program.
 The 'UIsound' variables link custom sound effects to program interactions like functions.
 The 'bgSound' variable enables to implement background music within their designs. The sound is playing at on loop if active.
 */


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– FIXED VARIABLES ––––––––––

// Soundfiles
SoundFile UIsound_add_1, UIsound_add_2, UIsound_delete_1, UIsound_delete_2, UIsound_switch_1, UIsound_switch_2,
  UIsound_random_1, UIsound_random_2, UIsound_set_1, UIsound_set_2, UIsound_setMax, UIsound_reset_1, UIsound_reset_2,
  UIsound_export, UIsound_exportComplete, UIsound_powerMove;
SoundFile bgSound;

// Oscilliators
Pulse UIsound_pulse;
SinOsc UIsound_sinOsc;
TriOsc UIsound_triOsc;


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– SETUP SOUND –––––––––––––––

public void setupSound() {
  UIsound_add_1 = new SoundFile(this, "interface/sound/Add1.mp3");
  UIsound_add_2 = new SoundFile(this, "interface/sound/Add2.mp3");
  UIsound_delete_1 = new SoundFile(this, "interface/sound/Delete1.mp3");
  UIsound_delete_2 = new SoundFile(this, "interface/sound/Delete2.mp3");
  UIsound_switch_1 = new SoundFile(this, "interface/sound/Switch1.mp3");
  UIsound_switch_2 = new SoundFile(this, "interface/sound/Switch2.mp3");
  UIsound_random_1 = new SoundFile(this, "interface/sound/Random1.mp3");
  UIsound_random_2 = new SoundFile(this, "interface/sound/Random2.mp3");
  UIsound_set_1 = new SoundFile(this, "interface/sound/Set1.mp3");
  UIsound_set_2 = new SoundFile(this, "interface/sound/Set2.mp3");
  UIsound_setMax = new SoundFile(this, "interface/sound/SetMax.mp3");
  UIsound_reset_1 = new SoundFile(this, "interface/sound/Reset1.mp3");
  UIsound_reset_2 = new SoundFile(this, "interface/sound/Reset2.mp3");
  UIsound_export = new SoundFile(this, "interface/sound/Export1.mp3");
  UIsound_exportComplete = new SoundFile(this, "interface/sound/Export2.mp3");
  UIsound_powerMove = new SoundFile(this, "interface/sound/PowerMove.mp3");

  File soundFolder = new File(dataPath("input/sound/"));
  File [] soundFiles = soundFolder.listFiles();
  if (soundFiles != null) {
    for (int i = 0; i<soundFiles.length; i++) {
      File tempFile = soundFiles[i];
      if (match(""+tempFile, ".aiff") != null || match(""+tempFile, ".mp3") != null) {
        bgSound = new SoundFile(this, "" + tempFile);
        break;
      }
    }
  }

  if (backgroundSound == true && bgSound != null) {
    bgSound.loop();
  }


  UIsound_pulse = new Pulse(this);
  UIsound_sinOsc = new SinOsc(this);
  UIsound_triOsc = new TriOsc(this);
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– PLAY INTERFACE SOUND ––––––

public void playSound(String command) {
  switch(command) {
  case "add":
    UIsound_add_1.play(1.0f, 0.3f);
    break;
  case "delete":
    UIsound_delete_1.play(1.0f, 0.3f);
    break;
  case "switch file":
    UIsound_switch_1.play(1.0f, 0.3f);
    break;
  case "switch active":
    UIsound_switch_1.play(1.0f, 0.3f);
    break;
  case "reorder":
    UIsound_set_1.play(1.0f, 0.3f);
    break;
      case "reorder max":
    UIsound_setMax.play(1.0f, 0.3f);
    break;
  case "switch letter":
    UIsound_set_2.play(1.0f, 0.3f);
    break;
  case "add letter":
    UIsound_add_2.play(1.0f, 0.3f);
    break;
  case "delete letter":
    UIsound_delete_2.play(1.0f, 0.3f);
    break;
  case "switch mode":
    UIsound_switch_2.play(1.0f, 0.3f);
    break;
  case "strokeweight":
    UIsound_set_2.play(1.0f, 0.3f);
    break;
  case "strokeweight max":
    UIsound_setMax.play(1.0f, 0.3f);
    break;
  case "color":
    UIsound_set_2.play(1.0f, 0.3f);
    break;
  case "background color":
    UIsound_set_1.play(1.0f, 0.3f);
    break;
  case "random":
    UIsound_random_2.play(1.0f, 0.3f);
    break;
  case "all random":
    UIsound_random_1.play(1.0f, 0.3f);
    break;
  case "delete drawing":
    UIsound_delete_2.play(1.0f, 0.3f);
    break;
  case "repetition":
    UIsound_set_2.play(1.0f, 0.3f);
    break;
  case "repetition max":
    UIsound_setMax.play(1.0f, 0.3f);
    break;
  case "delete repetition":
    UIsound_delete_2.play(1.0f, 0.3f);
    break;
  case "set animation speed":
    UIsound_set_2.play(1.0f, 0.3f);
    break;
  case "set animation speed max":
    UIsound_setMax.play(1.0f, 0.3f);
    break;
  case "delete animation":
    UIsound_delete_2.play(1.0f, 0.3f);
    break;
  case "reset":
    UIsound_reset_1.play(1.0f, 0.3f);
    break;
  case "export start":
    UIsound_export.play(1.0f, 0.3f);
    break;
  case "export finish":
    UIsound_exportComplete.play(1.0f, 0.3f);
    break;
  case "activate power move":
    UIsound_powerMove.play(1.0f, 0.3f);
    break;
  case "confirm power move":
    UIsound_add_2.play(1.0f, 0.3f);
    break;
  case "delete power move":
    UIsound_delete_2.play(1.0f, 0.3f);
    break;
  case "reset power move":
    UIsound_reset_2.play(1.0f, 0.3f);
    break;
  case "add combo":
    UIsound_set_2.play(1.0f, 0.3f);
    break;
  case "valid combo":
    UIsound_add_2.play(1.0f, 0.3f);
    break;
  case "invalid combo":
    UIsound_delete_2.play(1.0f, 0.3f);
    break;
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– INTERFACE SOUND –––––––––––

public void playSound(String command, float value) {
  switch(command) {
  case "move":
    UIsound_sinOsc.play(height-value, 0.05f);
    break;
  case "scale":
    UIsound_pulse.play(value*100, 0.01f);
    break;
  case "rotate":
    UIsound_triOsc.play(value*TWO_PI, 0.05f);
    break;
  }
}

public void endSound(String command) {
  switch(command) {
  case "move":
    UIsound_sinOsc.stop();
    break;
  case "scale":
    UIsound_pulse.stop();
    break;
  case "rotate":
    UIsound_triOsc.stop();
    break;
  }
}


// –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––-–––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– BACKGROUND SOUND ––––––––––

public void stopBackgroundSound() {
  if (bgSound != null) {
    bgSound.stop();
  }
}

public void playBackgroundSound() {
  if (bgSound != null) {
    bgSound.loop();
  }
}


  public void settings() { size(800, 800, FX2D); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "layoutTool" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
